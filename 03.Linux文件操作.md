# 1.操作系统与Linux io框架

## 1.1 io与操作系统

### 1.1.1 io概念

- io 描述的是硬件设备之间的数据交互，分为输⼊ (input) 与输出 (output)。
  - 输⼊：应⽤程序从其他设备获取数据 (read) 暂存到内存设备中；
  - 输出：应⽤程序将内存暂存的数据写⼊到其他设备 (write)。

### 1.1.2 操作系统概念

- 操作系统通常包含两种不同的含义

  - 第⼀种含义: 指完整的软件包 : 包括核⼼软件与应⽤软件。
    - 应⽤软件: 命令解释器, 图形⽤户界⾯, ⽂件操作⼯具与⽂件编辑器；
    - 核⼼软件: 管理和分配计算机资源 (这些计算机资源即 cpu,RAM, 其他设备)，即操作系统核⼼软件 (内核)。
  - 第⼆种含义: 专指操作系统核⼼软件 (内核)。我们以后就按第二种含义来理解。

  - 内核的职责如下:
    - 进程管理 : 分配 cpu 资源，⽤于执⾏程序指令；
    - 内存管理 : 如今计算机内存容量可谓相当可观, 但软件的规模也保持了相应的增⻓, 内存资源仍然属于有限资源, 内核必须公平与⾼效的管理内存资源, 其中虚拟内存管理技术；
    - ⽂件管理 : 允许对⽂件执⾏创建，获取，更新以及删除；
    - 设备管理 : 计算机外界设备可实现计算机与外部世界的通讯；
    - 联⽹管理 : 使计算机可以进⾏⽹络通讯；
    - 提供应⽤编程接⼝ (API): 进程可利⽤内核⼊⼝点请求内核区执⾏各种任务。

### 1.1.3 Linux操作系统结构

- Linux操作系统结构

  - ⼀般分为⽤户层与内核层

    - ⽤户层 : 表示在内核层之上的库 (如 glibc) 与 应⽤程序 (app)；
    - 内核层 : 操作系统内核；

  - ⽤户层与内核层是相辅相成，⽤户层的应⽤程序依赖于库或者内核, 库与内核给应⽤层提供服务；

  - 内核通过系统调⽤来给应⽤层提供接⼝。

    ![image-20240405203322952](assets/image-20240405203322952.png)

- 系统调用与库函数

  - 系统调⽤是 Linux 内核提供给应⽤程序的访问接⼝, 当需要 Linux 内核提供服务时, 则需要访问系统调⽤。
  - 库函数是为了实现某个功能⽽封装起来的 API 集合, 能够提供统⼀的编程接⼝，更加便于应⽤程序的移植。
  - glibc 是属于 GNU(GNU’s Not unix) ⼯程的⼀部分, 这个⼯程当初的⽬标是为了开发⼀款完整的操作系统, 但在开发过程中将除了 Linux 内核以外的组件都开发完成, 由于难度很⼤, 开发周期⻓, 在 1992 年 由 Linus Torvalds 开发出来了 Linux 内核, 填补了 GNU 系统的⼀个重要空⽩, 所有后⾯将 GNU 组件与 Linux 合并组成现在的 GNU/Linux。
  - glibc 包含 标准 c 库函数集合 和 系统调⽤
    - 标准的 c 库函数是跨平台的，既可以在 Linux 系统下调⽤, 也可以在 windows 系统下调⽤；
    - 系统调⽤是 Linux 内核给⽤户提供的访问接⼝, 但在 glibc 中封装了系统调⽤接⼝⽽形成了 glibc 的库函数；
    - glibc 库函数主要是封装了系统调⽤的过程, 相应的系统调⽤⼀般实现在 Linux 内核中；
    - ⼀般的 glibc 中的库函数都会与系统调⽤关联，但也有库函数不需要使⽤系统调⽤，⽐如字符串操作函数。

## 1.2 Linux io框架

### 1.2.1 Linux io框架介绍

- Linux io 框架也是分层设计, 这⾥以将内存中的数据存储到硬盘中为例

  ![image-20240405205101719](assets/image-20240405205101719.png)

- 应⽤程序通过调⽤操作系统提供的 io 接⼝ (函数) 向内核进⾏ io 请求 , 由内核最终完整相应的io操作；
- Linux io 框架基于⼀切皆⽂件的思想来设计；
  - ⽬的 : 屏蔽底层不同设备之间的 io 差异, 给应⽤层提供统⼀的操作接⼝；
  - 思想 : 即将底层的 io 操作统⼀抽象成⽂件操作，操作提供系统只需要提供⼀组⽂件 io操作接⼝就可以为应⽤程序提供 io 服务。

- ⽂件 io 操作主要包含:
  - open：打开
  - close：关闭
  - read：读取
  - write：写⼊
  - lseek：定位

- ⽂件 io 接⼝的设计本身来沿⽤了⼈的 操作习惯

  - ⼤脑相当于 内存设备
  - 书籍或者其他笔记本相当于另⼀个设备
  - 读书 : 相当于⼤脑获取数据 (read)
  - 写字 : 相当于将⼤脑数据写⼊到其他存储介质中

- 下⾯以 printf io 过程为例来说明

  ![image-20240405210304538](assets/image-20240405210304538.png)

  - printf io 的过程本质上是将暂存在内存中的数据写⼊到显示器中;

  - printf 函数⾸先会调⽤ glibc 中 write 函数来发出 io 请求;

  - write 函数在通过调⽤由操作系统内核提供的系统调⽤ sys_write 函数最终完成 io 操作.

  - 下⾯是 sys_write 系统调⽤在内核中的实现

    ```c++
    SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count)
    {
        struct fd f = fdget_pos(fd);
        ssize_t ret = -EBADF;
        if (f.file) 
        {
            loff_t pos = file_pos_read(f.file);
            ret = vfs_write(f.file, buf, count, &pos);
            if (ret >= 0)
            	file_pos_write(f.file, pos);
            fdput_pos(f);
        } 
        return ret; 
    }
    ```


# 2.Linux文件io接口

## 2.1 Linux文件io简介

### 2.1.1 关于Linux文件io

- 在 Linux 系统下, ⽤于对⽂件操作的库函数叫做⽂件 I/O；
- 主要包括 open()/close()/read()/write() /lseek() 相应的系统调⽤（准确说法是对系统调⽤的封装的库函数）。

### 2.1.2 文件描述符

- ⽂件描述符是⼀个⾮负整数 , 当打开⼀个已存在⽂件或者创建⼀个新⽂件时, 内核向进程返回⼀个⽂件描述符；

- 每个程序运⾏后, 操作系统会默认打开三个⽂件(标准输⼊、标准输出、标准错误输出) , ⽂件描述符分别为 0 , 1 , 2；

  - 标准输⼊对应的设备⼀般为键盘；
  - 标准输出与标准错误输出设备⼀般为显示器；

- 示例：通过 write 函数 (后⾯会详细讲解) 使⽤标准输出来打印 Hello world。

  ```c
  #include <stdio.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <errno.h>
  #include <unistd.h>
  int main(int argc,char *argv[])
  {
      write(1,"helloworld",10); 
      return 0;
  }
  ```

  

## 2.2 Linux文件io操作

### 2.2.1 open函数

- open函数说明

  - 函数功能

    - 打开文件，并得到文件描述符。

  - 函数原型

    ```c
    int open(const char *pathname, int flags);
    int open(const char *pathname, int flags, mode_t mode);
    ```

  - 头文件说明

    ```c
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    ```

  - 参数说明

    - pathname : ⽂件路径名
    - flags : 打开标志
      - O_RDONLY: 只读⽅式打开⽂件(read only)
      - O_WRONLY: 可写⽅式打开⽂件(write only)
      - O_RDWR: 读写⽅式打开⽂件(read write)
      - O_CREAT: 如果该⽂件不存在就创建⼀个新的⽂件，并⽤第三的参数为其设置权限
      - O_EXCL: 如果使⽤ O_CRATE 时⽂件存在, open() 报错（exclusive，排外的）
      - O_TRUNC: 如果⽂件已经存在，并且以读 / 写或只写成功打开, 并清零，即清空文件内容；
      - O_APPEND: 以添加的⽅式打开⽂件，在打开⽂件的同时，⽂件指针指向⽂件末尾
    - mode : 指定创建新的⽂件的默认权限

  - 返回值

    ```
    成功：返回⽂件描述符
    失败：返回-1, 并将错误编码保存到 errno
    ```

- 示例1：通过只读的⽅式打开⼀个⽂件

  ```c
  #include <stdio.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <errno.h>
  #include <unistd.h>
  #include <string.h>
  int main(int argc,char *argv[])
  {
      int fd; 
  
      if (argc != 2)
      { 
          /*
              int main(int argc, const char *argv[])
              argc:命令行传递参数的个数
              argv[0]:命令行传递的第一个参数
              argv[1]:命令行传递的第二个参数
              argv[2]:命令行传递的第三个参数
          */
          fprintf(stderr,"Usage : < %s > < pathname >\n", argv[0]);
          return -1; 
      } 
      fd = open(argv[1], O_RDONLY);
      
      if (fd == -1)
      {
          perror("Open(): ");
          return -1; 
      } 
  
      close(fd);
      return 0;
  }
  ```

- 练习：以只写的⽅式打开⽂件, 如果不存在则创建, 如果⽂件存在则截短（即清空文件内容）

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <unistd.h>
  int main(int argc,char *argv[])
  {
      int fd; 
      if(argc != 2)
      {
      	printf("Usage : %s <pathname> .\n",argv[0]);
      }
  
      fd = open(argv[1],O_WRONLY|O_CREAT|O_TRUNC,0644);
      if (fd == -1) 
      { 
      	perror("open()");
   		exit(-1);
   	} 
   	printf("fd = %d\n",fd);
   	close(fd);
   	return 0;
  }
  ```

  

- 函数错误处理与errno

  - errno 是 Linux 操作系统中⽤于存储错误编码的全局变量, 错误编码在 Linux 系统中的定义如下：

    ```c
    #define EPERM 1 
    #define ENOENT 2 
    #define ESRCH 3 
    #define EINTR 4 
    #define EIO 5 
    #define ENXIO 6 
    #define E2BIG 7 
    #define ENOEXEC 8 
    #define EBADF 9 
    #define ECHILD 10 
    #define EAGAIN 11 
    #define ENOMEM 12 
    #define EACCES 13 
    #define EFAULT 14 
    #define ENOTBLK 15 
    #define EBUSY 16
    ```


- 错误信息打印

  - 错误信息打印主要使用perror() 函数。

    - 函数头文件

      ```c
      #include <stdio.h>
      ```

    - 函数原型

      ```c
      void perror(const char *s)
      ```

    - 函数参数

      ```
      s : ⾃定义字符串参数
      ```

  - 错误信息转换主要使⽤ strerror() 函数, 具体说明如下：

    - 函数头文件

      ```c
      #include <string.h>
      ```

    - 函数原型

      ```c
      char *strerror(int errnum)
      ```

    - 函数功能

      将错误编码转换成字符串信息，并返回该字符串的地址。

    - 函数参数

      ```
      errnum : 错误编码
      ```

    - 函数返回值

      返回错误码转换之后的字符串 or “Unknown error nnn”。

    - 示例 : 使⽤ perror 函数打印 出错信息

      ```c
      #include <stdio.h>
      #include <sys/types.h>
      #include <sys/stat.h>
      #include <fcntl.h>
      int main(int argc,char *argv[])
      {
          int fd; 
          fd = open(argv[1],O_RDONLY,0644);
          if (fd == -1) 
          { 
              perror("open(): ");
              //perror(strerror(EIO));
              //将错误编码EIO转换成出错信息字符串，通过perror函数将出错信息字符串打印出来
              return -1; 
          } 
          return 0;
      }
      ```

### 2.2.2 close函数

- close函数说明

  - 函数头文件

    ```c
    #include <unistd.h>
    ```

  - 函数原型

    ```c
    int close(int fd);
    ```

  - 函数功能

    close 函数⽤于关闭⽂件，在 io 操作结束后需要关闭⽂件，释放相关资源。

  - 函数参数

    ```
    fd : ⽂件描述符
    ```

  - 函数返回值

    ```
    成功：返回0
    失败：返回-1
    ```

- 示例：将前⾯已经打开的⽂件使⽤ close 函数关闭。



### 2.2.3 read函数

- 函数头文件

  ```c
  #include <unistd.h>
  ```

- 函数原型

  ```c
  ssize_t read(int fd, void *buf, size_t count)
  ```

- 函数功能

  从⽂件中读取数据保存缓冲区中。

- 函数参数

  ```c
  fd : ⽂件描述符
  buf : 数据缓冲区
  count : 能够读取的最⼤字节数
  ```

- 函数返回值

  ```
  成功 : 返回实际读取的字节数
  失败 : -1, 并将错误编码设置到 errno 中
  ```

- 示例：从指定⽂件中读取 10 个字节数据，并进⾏打印

  ```c
  #include <stdio.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h> 
  #include <errno.h>
  #include <unistd.h>
  int main(int argc,char *argv[])
  {
      int fd;
      char buffer[64] = {0};
      ssize_t rbytes;
      if (argc != 2)
      {
          fprintf(stderr,"Usage : < %s > < pathname >\n",argv[0]);
          return -1; 
      }
      fd = open(argv[1],O_RDONLY); 
      if (fd == -1)
      { 
          perror("Open(): ");
          return -1;
   	}
      rbytes = read(fd,buffer,10);
      if (rbytes == -1)
      {
      	perror("Read(): ");
      	return -1;
      }
   	printf("Buffer : %s\n",buffer);
  	close(fd);
   	return 0;
  }
  ```

### 2.2.4 write函数

- 函数头文件

  ```c
  #include <unistd.h>
  ```

- 函数原型

  ```c
  ssize_t write(int fd, const void *buf, size_t count);
  ```

- 函数功能

  把缓冲区中的数据写入到指定文件中。

- 函数参数

  ```
  fd : ⽂件描述符
  buf : 缓冲区地址
  count : 需要写⼊的字节数
  ```

- 函数返回值

  ```
  成功: 返回实际成功写⼊的字节数
  失败: 返回 -1, 并设置 errno
  ```

- 示例：将 ABCDE12345 字符串写⼊到指定⽂件中, 并验证是否写⼊正确

  ```c
  #include <stdio.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <errno.h>
  #include <unistd.h>
  int main(int argc,char *argv[])
  {
      int fd;
      char buffer[64] = "ABCED12345";
      ssize_t wbytes;
      if (argc != 2)
      {
          fprintf(stderr,"Usage : < %s > < pathname >\n",argv[0]);
          return -1;
      }
      fd = open(argv[1],O_RDWR|O_CREAT);
      if (fd == -1)
      {
          perror("Open(): ");
          return -1;
      }
      wbytes = write(fd,buffer,10);
      if (wbytes == -1)
      {
          perror("Write(): ");
          return -1;
      }
      close(fd);
      return 0;
  }
  ```

  

### 2.2.5 lseek函数

- 函数原型

  ```c
  off_t lseek(int fd, off_t offset, int whence);
  ```

- 函数参数

  - fd : ⽂件描述符
  - offset : 偏移量, 可以为正数或者负数
  - whence : 偏移相对位置
    - SEEK_CUR : 相对于⽂件当前偏移
    - SEEK_SET : 相对于⽂件开始位置
    - SEEK_END : 相对于⽂件尾偏移

- 函数返回值

  - 成功: 返回 0
  - 失败 : 返回 -1, 并设置 errno
  - 当前⽂件的偏移量决定下次 io 操作时的起始位置
  - 对于同⼀个⽂件描述符，共享同⼀个偏移量

- 示例：将⼀个字符串 "hello,linux io" 写⼊到⽂件中，在读取出来

  ```c
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <errno.h>
  #include <unistd.h>
  #include <string.h>
  int main(int argc,char *argv[])
  {
      int fd; 
      char buffer[64] = "hello,Linux io";
      char rbuffer[64] = {0};
      ssize_t wbytes = 0,rbytes = 0;
      if (argc != 2)
      { 
          fprintf(stderr,"Usage : < %s > < pathname >\n",argv[0]);
          return -1; 
      } 
      fd = open(argv[1],O_RDWR|O_CREAT);
      if (fd == -1)
      {
          perror("Open(): ");
          return -1; 
      } 
  
      wbytes = write(fd,buffer,strlen(buffer));
      if (wbytes == -1)
      {
          perror("Write(): ");
          return -1;
      } 
      lseek(fd,0,SEEK_SET);
      rbytes = read(fd,rbuffer,wbytes);
      if (rbytes == -1)
      {
          perror("Read(): ");
          return -1; 
      } 
      printf("rbuffer : %s\n",rbuffer);
      close(fd);
      return 0;
  }
  ```

  

- 练习 : 使⽤ Linux ⽂件 io 接⼝实现 ⽂件复制

  ```c
  #include <unistd.h>
  #include <string.h>
  int main(int argc, const char *argv[])
  {
  	if(argc != 3)
  	{
  		fprintf(stderr, "Usage : <%s> <pathname>\n", argv[0]);
  		return -1;
  	}
  	int source_fd = open(argv[1], O_RDONLY);
  	int destination_fd = open(argv[2], O_RDWR | O_CREAT);
  	int rbytes = 0;
  	char buffer[64] = {0};
  	if(source_fd == -1 || destination_fd == -1)
  	{
  		perror("open()");
  		return -1;
  	}
  	while(rbytes = read(source_fd, buffer, 64))
  	{
  		if(rbytes == -1)
  		{
  			perror("read()");
  			return -1;
  		}
  		int wbytes = write(destination_fd, buffer, rbytes);
  		if(wbytes == -1)
  		{
  			perror("write()");
  			return -1;
  		}
  	}
  
  	close(source_fd);
  	close(destination_fd);
  	return 0;
  }
  ```

# 3.Linux标准io接口

## 3.1 标准io简介

### 3.1.1 标准io与文件io

- 标准 IO 是另外⼀套 IO 接⼝，具有如下特点:
  - 标准 I/O 是属于跨平台, 可以在 Linux、windows、mac os 上运⾏, ⽂件 IO 只能在Linux 平台运⾏
  - 标准 I/O ⾃带缓冲区，有更⾼的 IO 效率
  - 标准 IO 提供丰富的操作⽂本信息接⼝
  - 标准 IO 底层需要依赖于 ⽂件 IO
  - 在 Linux 系统下, 标准 I/O 是属于 glibc 库的⼀部分

![image-20240411213708601](assets/image-20240411213708601.png)

### 3.1.2 流与FILE对象

- 流（stream）：流是⼀串连续不断的传输的数据的集合，就像⽔管⼀⾥的⽔流，在⽔管的⼀端⼀点⼀点地供⽔，⽽在⽔管的另⼀端看到的是⼀股连续不断的⽔流。

- ⼀般流可以分为 ⽂本流 与 ⼆进制流

  - ⽂本流：
    - 在流中处理的数据是以字符出现。
    - 在⽂本流中，’\n’被转换成回⻋符 CR 和换⾏符 LF的 ASCII 码 0DH 和 0AH, ⽽当输出时，0DH 和 0AH 被转换成’\n’。
  - 二进制流：
    - 流中处理的是⼆进制序列。
    - 若流中有字符，则⽤⼀个字节的⼆进制 ASCII 码表示；若是数字，则⽤对应的⼆进制数表示

- ⽂件指针:

  - FILE 指针：每个被使⽤的⽂件都在内存中开辟⼀个区域，⽤来存放⽂件的有关信息，这些信息是保存在⼀个结构体类型的变量中，该结构体类型是由系统定义的，取名为 FILE。

  - FILE 结构体定义在 /usr/libio.h 中 struct _IO_FILE

    ```c
     struct _IO_FILE;
     typedef struct _IO_FILE __FILE;
    ```

  - 标准 I/O 库的所有操作都是围绕流 (stream) 来进⾏的，在标准 I/O 中，流⽤ FILE * 来描述
  - 标准 I/O 库是由 Dennis Ritchie 在 1975 年左右编写的

- ⽂件指针关联到数据流的两端, 可以抽象成 “⽔管”

## 3.2 标准输入、标准输出、标准错误输出

### 3.2.1 简介

- 标准 I/O 预定义 3 个流对象指针, 在应⽤程序运⾏⾃动被打开.
  - 标准输⼊ : 流对象操作的是标准输⼊设备, 流对象指针的名称为 stdin , 对应的⽂件描述符为 0
  - 标准输出 : 流对象操作的是标准输出设备, 流对象指针的名称为 stdout, 对应的⽂件描述符为 1
  - 标准错误输出: 流对象操作的是标准错误输出设备, 流对象指针的名称为 stderr, 对应的⽂件描述符为 2
- 对应的 printf , 函数操作的就是 stdout , 由于是默认操作, ⼀般⽆需指定具体的流对象参数
- 当在输出时需要指定流对象的类型时, 则需要使⽤ fprintf 函数

### 3.2.2 fprintf函数

- 函数原型

  ```
  int fprintf(FILE *stream, const char *format, …);
  ```

- 函数功能

  将格式化数据写⼊到指定⽂件中。

- 函数参数

  ```
  stream : 流对象指针
  format : 格式字符串
  ```

  

- 示例 : 通过 stdout 与 stderr 进⾏输出

  ```c
  int main(void)
  {
      fprintf(stdout,"Linux std io .\n");
      fprintf(stderr,"can't open file.\n"); 
      while(1){}
      return 0;
  }
  
  ```

  - 注意: 在上述程序中, 将 ‘\n’ 去掉之后, 在添加⼀个死循环后, 则程序运⾏的结果则不同, 这⾥是 与标准 I/O 的缓冲区有关系.

### 3.2.3 文件缓冲

- 文件缓冲系统
  - 缓冲文件系统
    - 尽量减少使⽤ read/write 的调⽤次数, 来提⾼效率, 每次进⾏系统调⽤都会涉及到从 ⽤户空间到内核空间的切换以及内核进⾏系统调⽤所产⽣的开销 
    - 系统⾃动的在内存中为每⼀个正在使⽤的⽂件开辟⼀个缓冲区，从内存向磁盘输出数据必须先 送到内存缓冲区，装满缓冲区在⼀起送到磁盘中去. 
    - 从磁盘中读数据，则⼀次从磁盘⽂件将⼀批数据读⼊到内存缓冲区中，然后再从缓冲区逐个的 将数据送到程序的数据区

![image-20240411215121607](assets/image-20240411215121607.png)

- 标准 I/O 的缓存⼤⼩为 8192, 在系统中定义如下 (stdio.h):

  ```C
  #define BUFSIZE 8192
  ```

  

-  ⼀般标准 I/O 的分类为: 

  - 全缓存 : 当相应的缓冲区已经装满数据时, 才进⾏⼀次 I/O 操作 
  - ⾏缓存 : 当相应的缓冲区存储⼀⾏时，则进⾏⼀次 I/O 操作, stdout 就是⾏缓存 
  - 不缓存 : 直接进⾏ I/O 操作, 不进⾏缓存, stderr 就是不缓存 

### 3.2.4 缓冲区强制刷新

- ⼀般情况下, 程序在结束时会 ⾃动刷新缓冲区, 但是当程序还未结束时, 刷新缓冲区则需要调⽤ fflush() 函数

  - 函数原型

    ```
    int fflush(FILE *stream);
    ```

  - 函数功能

    强制刷新缓冲区。
    
  - 函数参数

    ```
    stream：流对象指针
    ```

  - 函数返回值

    ```
    成功：返回0
    失败：返回-1
    ```

- 示例 : 使⽤ fflush 函数刷新缓冲区的数据

  ```c
  #include <stdio.h>
  int main(void)
  {
      printf("hello.");
      fflush(stdout);
      while(1){}
      return 0;
  }
  ```

- 练习 : 使⽤ fprintf 函数 "Hello,Linux io" 到 标准输出，并使⽤ fflush 函数进⾏强制刷新.

  ```c
  #include <stdio.h>
  
  int main(int argc, const char *argv[])
  {
  	fprintf(stdout, "Hello, Linux io");
  	fflush(stdout);	
  	while(1){}
  	return 0;
  }
  
  ```

  

## 3.3 Linux标准io-fopen/fclose

### 3.3.1 fopen函数

- 函数头文件

  ```c
  #include <stdio.h>
  ```

- 函数原型

  ```c
   FILE *fopen(const char *pathname, const char *mode);
  ```

- 函数功能

  打开⽂件，并获取流对象指针.

- 函数参数

  - pathname : 路径名
  - mode : 打开模式
    - r或rb：以只读方式打开⽂件，前提是该⽂件必须存在
    - r+或r+b：以可读可写方式打开⽂件，前提是该⽂件必须存在
    - w或wb：以只写方式打开⽂件，若⽂件存在则⽂件⻓度清为 0, 即会清空⽂件以前内容。若⽂件不存在则创建该⽂件.
    - w+或w+b或wb+：以可读可写方式打开⽂件，若⽂件存在则⽂件⻓度清为零，即会清空⽂件以前内容， 若⽂件不存在则创建该⽂件.
    - a或ab：以只写与追加的方式打开文件，若⽂件不存在，则会新建该⽂件, 如果⽂件存在，写⼊的数据会被加到⽂件尾，即⽂件原先的内容会被保留。

- 函数返回值

  - 成功：返回⽂件指针
  - 失败：返回 NULL, 并设置 errno

### 3.3.2 fclose函数

- 函数头文件

  ```c
  #include <stdio.h>
  ```

- 函数原型

  ```
  int fclose(FILE *stream);
  ```

- 函数功能

  关闭已经打开的⽂件.

- 函数参数

  ```
  stream : ⽂件指针
  ```

- 示例 : 以读写⽅式打开⽂件 test.txt，如果该⽂件不存在，则创建. 如果该⽂件已经存在，则⻓度截短为 0.

  ```c
  int main(int argc, const char *argv[])
  {
  	if(argc != 2)
  	{
  		fprintf(stderr, "usage <%s> <pathname>\n", argv[1]);
  		return -1;
  	}
  
  	FILE* fd = NULL;
  	fd = fopen(argv[1], "w+");
  	if(fd == NULL)
  	{
  		fprintf(stderr, "fopen()\n");
  		return -1;
  	}
  
  	return 0;
  }
  ```

## 3.4 Linux标准io-fgetc/fputc

### 3.4.1 fgetc函数

- 函数头文件

  ```c
  #include <stdio.h>
  ```

- 函数功能

  从文件中读取一个字符。

- 函数原型

  ```c
  int fgetc(FILE* stream);
  ```

- 函数参数

  ```
  stream:文件指针
  ```

- 函数返回值

  - 成功：返回所读到字符的ASCII码
  - 失败：返回EOF

  

### 3.4.2 fputc函数

- 函数头文件

  ```c
  #include <stdio.h>
  ```

- 函数功能

  输出一个字符到文件中；

- 函数原型

  ```c
  int fputc(int c, FILE* stream);
  ```

- 函数参数

  ```
  c:待写⼊的字符
  stream:文件指针
  ```

- 函数返回值

  - 成功：返回写入字符的ASCII码
  - 失败：返回EOF，并设置errno

- 示例 : 实现 cat 命令功能, 将⽂件中的数据显示到 stdout 上.

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  int main(int argc,char *argv[])
  {
      FILE *fp = NULL;
      if (argc != 2)
      {   
          fprintf(stderr,"Usage : ./a.out <filename>\n"); 
          exit(-1);
      }   
      fp = fopen(argv[1],"r");
      if (fp == NULL)
      {   
      	fprintf(stderr,"fopen failed.\n");  
      	exit(-1);
      }   
      
      char ch; 
      for (;;){
      	ch = fgetc(fp);
      	if (ch == EOF)
      		break;
      	fputc(ch,stdout);
      }
      fclose(fp);
      return 0;
  }
  ```

  练习: 使⽤ fgetc 与 fputc 实现⽂件复制功能
  
  ```c
  #include <stdio.h>
  
  int main(int argc, const char *argv[])
  {
  	FILE *src_fd = NULL, *des_fd = NULL;
  	char ch;
  	if(argc != 3)
  	{
  		fprintf(stderr, "usage <%s> <pathname>\n", argv[0]);
  		return -1;
  	}
  	src_fd = fopen(argv[1], "r");
  	des_fd = fopen(argv[2], "w+");
  	if(src_fd == NULL || des_fd == NULL)
  	{
  		fprintf(stderr, "fopen()\n");
  		return -1;
  	}
  	while((ch = fgetc(src_fd)) != EOF)
  	{
  		fputc(ch, des_fd);
  	}
  
  	fclose(src_fd);
  	fclose(des_fd);
  	return 0;
  }
  ```

## 3.5 Linux标准io-fgets/fputs

### 3.5.1 fgets函数

- 函数头文件

  ```c
  #include <stdio.h>
  ```

- 函数功能

  从文件中读取一行数据到缓冲区中。

- 函数原型

  ```c
  char *fgets(char *s, int size, FILE *stream);
  ```

- 函数参数

  ```
  s : 缓冲区地址
  size : 最⼤可读取⼤⼩
  stream : ⽂件指针
  ```

- 函数返回值

  ```
  成功 : 返回缓冲区的地址, 当读到⽂件尾时,会返回 NULL
  失败 : 返回 NULL
  ```

- 使⽤注意点
  - 会将’\n’ 存储到 buffer 中
  - 会⾃动在 buffer 的末尾添加’\0’
  - 如果⼀⾏⼩于 size, 读取到⼀⾏就返回
  - 如果 size ⼩于⼀⾏, 读取 size 返回

### 3.5.2 fputs函数

- 函数头文件

  ```c
  #include <stdio.h>
  ```

- 函数功能

  将一行文本数据写入到文件中。

- 函数原型

  ```c
  int fputs(const char *s, FILE *stream);
  ```

- 函数参数

  ```
  s:缓冲区地址
  stream:文件指针
  ```

- 函数返回值

  ```
  成功：返回⼀个⾮负数
  失败：返回 EOF
  ```

- 示例：使⽤ fgets 与 fputs 输出⽂件内容到 stdout 上

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <errno.h>
  #include <string.h>
  int main(int argc,char *argv[])
  {
      FILE *fp = NULL;
      char buffer[64];
  
      fp = fopen(argv[1],"r");
      if (fp == NULL)
      { 
          fprintf(stderr,"cat't open file");
          exit(-1);
      } 
  
      while(fgets(buffer,64,fp) != NULL)
      { 
      	fputs(buffer,stdout); 
      } 
      fclose(fp);
      return 0;
  }
  ```

  

- 练习：使⽤ fputs 与 fgets 来复制⽂件

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  
  
  int main(int argc, const char *argv[])
  {
  	FILE *src_fd = NULL, *des_fd = NULL;
  	char buffer[64] = {0};
  	int buffer_size = sizeof(buffer);
  	if(argc != 3)
  	{
  		fprintf(stderr, "Usage <%s> <pathname>\n", argv[0]);
  		return -1;
  	}
  	src_fd = fopen(argv[1], "r");
  	des_fd = fopen(argv[2], "w+");
  	if(src_fd == NULL || des_fd == NULL)
  	{
  		fprintf(stderr, "fopen()\n");
  		exit(-1);
  	}
  	while((fgets(buffer, buffer_size, src_fd)) != NULL)
  	{
  		fputs(buffer, des_fd);
  	}
  	fclose(src_fd);
  	fclose(des_fd);
  	return 0;
  }
  ```


## 3.6 Linux标准io-格式化输入输出与时间获取

当遇到典型的格式化数据进⾏处理时, 就需要相应⽤于格式化输⼊ / 输出的函数来完成, ⽐如⽇期就是典型的具有格式的数据

⽇期数据 : 2022 年 10 ⽉ 22 ⽇

地址数据 : 湖北省武汉市…

### 3.6.1 格式化输出函数

![image-20240416211114978](assets/image-20240416211114978.png)

- printf函数

  - 函数头文件

    ```c
    #include <stdio.h>
    ```

  - 函数功能

    输出信息到标准输出。

  - 函数原型

    ```c
    int printf(const char *format, …);
    ```

  - 函数返回值

    实际输出的字节数。

- fprintf函数

  - 函数头文件

    ```c
    #include <stdio.h>
    ```

  - 函数功能

    将格式化数据输出到文件。

  - 函数原型

    ```c
    int fprintf(FILE *stream, const char *format, …);
    ```

  - 函数参数

    ```
    stream : 流对象指针
    format : 格式字符串
    ```

  - 函数返回值

    实际输出的字节数。

- sprintf函数

  - 函数头文件

    ```c
    #include <stdio.h>
    ```

  - 函数功能

    将格式化数据输出到字符串缓冲区中。

  - 函数原型

    ```c
    int sprintf(char *str, const char *format, …);
    ```

  - 函数参数

    ```
    str : 字符串缓冲区地址
    format : 格式字符串地址
    ```

  - 函数返回值

    实际输出的字节数。

### 3.6.2 格式化输入函数

![image-20240416212412347](assets/image-20240416212412347.png)

- scanf函数

  - 函数头文件

    ```c
    #include <stdio.h>
    ```

  - 函数功能

    从标准输⼊读取格式化数据到缓冲区中。

  - 函数原型

    ```c
    int scanf(const char *format, …);
    ```

  - 函数参数

    ```
    format : 格式字符串地址
    ```

  - 函数返回值

    实际读取的字节数。

- fscanf函数

  - 函数头文件

    ```c
    #include <stdio.h>
    ```

  - 函数功能

    从⽂件中读取格式化数据。

  - 函数原型

    ```c
    int fscanf(FILE *stream, const char *format, …);
    ```

  - 函数参数

    ```
    stream : 流对象指针
    format : 格式字符串地址
    ```

  - 函数返回值

    实际读取的字节数。

  - 例：格式化输出

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <errno.h>
    #include <string.h>
    int main(int argc,char *argv[])
    {
        FILE *fp = NULL; 
    
        fp = fopen(argv[1],"w");
        if ( fp == NULL)
        { 
            fprintf(stderr,"can't open file.\n");
            return -1;
        } 
        int numa = 10; 
        float numb = 1.23456;
        char *str = "Hello";
        char buffer[64];
        fprintf(fp,"%d-%f-%s",numa,numb,str);
        sprintf(buffer,"%d-%f-%s",numa,numb,str);
        puts(buffer);
        fclose(fp);
        return 0;
    }
    ```

    

- sscanf函数

  - 函数头文件

    ```c
    #include <stdio.h>
    ```

  - 函数功能

    从字符串读取格式化数据。

  - 函数原型

    ```c
    int sscanf(const char *str, const char *format, …);
    ```

  - 函数参数

    ```
    str : 字符串地址
    format : 格式字符串地址
    ```

  - 函数返回值

    实际读取的字节数。

  - 例：格式化输入

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    int main(int argc,char *argv[])
    {
        FILE *fp = NULL; 
        int numa = 0,numb = 0,numc = 0; 
        char buffer[64] = "10-20-30";
        if (argc != 2)
        { 
            fprintf(stderr,"Usage : %s <pathname> \n",argv[0]);
            return -1; 
        } 
        fp = fopen(argv[1],"r");
        if (fp == NULL)
        {
            perror("Error fopen(): ");
            return -1; 
        } 
    
        fscanf(fp,"%d-%d-%d",&numa,&numb,&numc);
    
        printf("numa = %d,numb = %d,numc = %d\n",numa,numb,numc);
        numa = 0,numb = 0,numc = 0;
        sscanf(buffer,"%d-%d-%d",&numa,&numb,&numc);
        printf("numa = %d,numb = %d,numc = %d\n",numa,numb,numc);
        fclose(fp);
        return 0;
    }
    ```

### 3.6.3 获取系统时间

- 在 Linux 中获取主要需要以下两个步骤

  - Step 1 : 通过 time() 函数获取从 1970 年⾄今的秒数

  - Step 2 : 通过 localtime() 或者 ctime() 函数

- time函数

  - 函数头文件

    ```c
    #include <time.h>
    ```

  - 函数功能

    获取从 1970-1-1 ⾄今的时间秒数 (时间戳)。

  - 函数原型

    ```c
    time_t time(time_t *tloc);
    ```

  - 函数参数

    ```
    tloc:输出参数，存储时间变量的指针。
    
    ```

  - 函数返回值

    ```
    如果参数为空，则返回当前时间距1970年1月1日00:00点 UTC的秒数；
    如果参数不为空，此时返回值和参数都为当前时间距1970年1月1日00:00点 UTC的秒数。
    ```

  - 注意：

    ```
    UTC就是一个全世界都用的“标准时间”。这个时间是基于非常准确的原子钟来计算的，所以非常准确。
    UTC就像一把全球统一的“尺子”，用来量时间。这样，不论你在世界的哪个角落，只要提到UTC时间，大家都知道现在是几点。
    当然，每个地方因为日出日落的时间不同，所以会在UTC的基础上加或者减几个小时，形成自己的地方时间。
    但UTC时间就像一个基准，帮助大家更好地理解和沟通时间。
    ```

- localtime函数

  - 函数头文件

    ```c
    #include <time.h>
    ```

  - 函数功能

    将时间戳转换成本地时间, 并存储到 struct tm 结构体变量中。

  - 函数原型

    ```c
    struct tm *localtime(const time_t *timep);
    ```

  - 函数参数

    ```
    timep：这是一个指向 time_t 类型变量的指针，该变量包含了要转换的时间。
    ```

  - 函数返回值

    ```
    返回 struct tm 结构体指针
    ```

    `struct tm` 的定义大致如下：

    ```c
    struct tm {
        int tm_sec;    /* Seconds (0-60) */
        int tm_min;    /* Minutes (0-59) */
        int tm_hour;   /* Hours (0-23) */
        int tm_mday;   /* Day of the month (1-31) */
        int tm_mon;    /* Month (0-11) */
        int tm_year;   /* Year - 1900 */
        int tm_wday;   /* Day of the week (0-6, Sunday = 0) */
        int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
        int tm_isdst;  /* Daylight saving time */
    };
    ```

  - 获取当前时间并转换本地时间，以 %d-%d-%d %d::%d::%d 进⾏打印

    ```c
    #include <stdio.h>
    #include <time.h>
    int main(void)
    {
        time_t t;
    
        struct tm *p_datetime;
        t = time(NULL);
        p_datetime = localtime(&t);
        printf(" %d-%d-%d %d::%d::%d\n"
        	,p_datetime->tm_year + 1900
        	,p_datetime->tm_mon + 1
        	,p_datetime->tm_mday
        	,p_datetime->tm_hour
        	,p_datetime->tm_min 
        	,p_datetime->tm_sec );
        return 0;
    }
    ```

    练习 :

    获取系统时间，按照 <2022-5-8 23::15:00> 格式写⼊到⽂件中

    



