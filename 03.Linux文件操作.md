# 1.操作系统与Linux io框架

## 1.1 io与操作系统

### 1.1.1 io概念

- io 描述的是硬件设备之间的数据交互，分为输⼊ (input) 与输出 (output)。
  - 输⼊：应⽤程序从其他设备获取数据 (read) 暂存到内存设备中；
  - 输出：应⽤程序将内存暂存的数据写⼊到其他设备 (write)。

### 1.1.2 操作系统概念

- 操作系统通常包含两种不同的含义

  - 第⼀种含义: 指完整的软件包 : 包括核⼼软件与应⽤软件。
    - 应⽤软件: 命令解释器, 图形⽤户界⾯, ⽂件操作⼯具与⽂件编辑器；
    - 核⼼软件: 管理和分配计算机资源 (这些计算机资源即 cpu,RAM, 其他设备)，即操作系统核⼼软件 (内核)。
  - 第⼆种含义: 专指操作系统核⼼软件 (内核)。我们以后就按第二种含义来理解。

  - 内核的职责如下:
    - 进程管理 : 分配 cpu 资源，⽤于执⾏程序指令；
    - 内存管理 : 如今计算机内存容量可谓相当可观, 但软件的规模也保持了相应的增⻓, 内存资源仍然属于有限资源, 内核必须公平与⾼效的管理内存资源, 其中虚拟内存管理技术；
    - ⽂件管理 : 允许对⽂件执⾏创建，获取，更新以及删除；
    - 设备管理 : 计算机外界设备可实现计算机与外部世界的通讯；
    - 联⽹管理 : 使计算机可以进⾏⽹络通讯；
    - 提供应⽤编程接⼝ (API): 进程可利⽤内核⼊⼝点请求内核区执⾏各种任务。

### 1.1.3 Linux操作系统结构

- Linux操作系统结构

  - ⼀般分为⽤户层与内核层

    - ⽤户层 : 表示在内核层之上的库 (如 glibc) 与 应⽤程序 (app)；
    - 内核层 : 操作系统内核；

  - ⽤户层与内核层是相辅相成，⽤户层的应⽤程序依赖于库或者内核, 库与内核给应⽤层提供服务；

  - 内核通过系统调⽤来给应⽤层提供接⼝。

    ![image-20240405203322952](assets/image-20240405203322952.png)

- 系统调用与库函数

  - 系统调⽤是 Linux 内核提供给应⽤程序的访问接⼝, 当需要 Linux 内核提供服务时, 则需要访问系统调⽤。
  - 库函数是为了实现某个功能⽽封装起来的 API 集合, 能够提供统⼀的编程接⼝，更加便于应⽤程序的移植。
  - glibc 是属于 GNU(GNU’s Not unix) ⼯程的⼀部分, 这个⼯程当初的⽬标是为了开发⼀款完整的操作系统, 但在开发过程中将除了 Linux 内核以外的组件都开发完成, 由于难度很⼤, 开发周期⻓, 在 1992 年 由 Linus Torvalds 开发出来了 Linux 内核, 填补了 GNU 系统的⼀个重要空⽩, 所有后⾯将 GNU 组件与 Linux 合并组成现在的 GNU/Linux。
  - glibc 包含 标准 c 库函数集合 和 系统调⽤
    - 标准的 c 库函数是跨平台的，既可以在 Linux 系统下调⽤, 也可以在 windows 系统下调⽤；
    - 系统调⽤是 Linux 内核给⽤户提供的访问接⼝, 但在 glibc 中封装了系统调⽤接⼝⽽形成了 glibc 的库函数；
    - glibc 库函数主要是封装了系统调⽤的过程, 相应的系统调⽤⼀般实现在 Linux 内核中；
    - ⼀般的 glibc 中的库函数都会与系统调⽤关联，但也有库函数不需要使⽤系统调⽤，⽐如字符串操作函数。

## 1.2 Linux io框架

### 1.2.1 Linux io框架介绍

- Linux io 框架也是分层设计, 这⾥以将内存中的数据存储到硬盘中为例

  ![image-20240405205101719](assets/image-20240405205101719.png)

- 应⽤程序通过调⽤操作系统提供的 io 接⼝ (函数) 向内核进⾏ io 请求 , 由内核最终完整相应的io操作；
- Linux io 框架基于⼀切皆⽂件的思想来设计；
  - ⽬的 : 屏蔽底层不同设备之间的 io 差异, 给应⽤层提供统⼀的操作接⼝；
  - 思想 : 即将底层的 io 操作统⼀抽象成⽂件操作，操作提供系统只需要提供⼀组⽂件 io操作接⼝就可以为应⽤程序提供 io 服务。

- ⽂件 io 操作主要包含:
  - open：打开
  - close：关闭
  - read：读取
  - write：写⼊
  - lseek：定位

- ⽂件 io 接⼝的设计本身来沿⽤了⼈的 操作习惯

  - ⼤脑相当于 内存设备
  - 书籍或者其他笔记本相当于另⼀个设备
  - 读书 : 相当于⼤脑获取数据 (read)
  - 写字 : 相当于将⼤脑数据写⼊到其他存储介质中

- 下⾯以 printf io 过程为例来说明

  ![image-20240405210304538](assets/image-20240405210304538.png)

  - printf io 的过程本质上是将暂存在内存中的数据写⼊到显示器中;

  - printf 函数⾸先会调⽤ glibc 中 write 函数来发出 io 请求;

  - write 函数在通过调⽤由操作系统内核提供的系统调⽤ sys_write 函数最终完成 io 操作.

  - 下⾯是 sys_write 系统调⽤在内核中的实现

    ```c++
    SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count)
    {
        struct fd f = fdget_pos(fd);
        ssize_t ret = -EBADF;
        if (f.file) 
        {
            loff_t pos = file_pos_read(f.file);
            ret = vfs_write(f.file, buf, count, &pos);
            if (ret >= 0)
            	file_pos_write(f.file, pos);
            fdput_pos(f);
        } 
        return ret; 
    }
    ```


# 2.Linux文件io接口-open/close

## 2.1 Linux文件io简介

### 2.1.1 关于Linux文件io

- 在 Linux 系统下, ⽤于对⽂件操作的库函数叫做⽂件 I/O；
- 主要包括 open()/close()/read()/write() /lseek() 相应的系统调⽤（准确说法是对系统调⽤的封装的库函数）。

### 2.1.2 文件描述符

- ⽂件描述符是⼀个⾮负整数 , 当打开⼀个已存在⽂件或者创建⼀个新⽂件时, 内核向进程返回⼀个⽂件描述符；

- 每个程序运⾏后, 操作系统会默认打开三个⽂件(标准输⼊、标准输出、标准错误输出) , ⽂件描述符分别为 0 , 1 , 2；

  - 标准输⼊对应的设备⼀般为键盘；
  - 标准输出与标准错误输出设备⼀般为显示器；

- 示例：通过 write 函数 (后⾯会详细讲解) 使⽤标准输出来打印 Hello world。

  ```c
  #include <stdio.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <errno.h>
  #include <unistd.h>
  int main(int argc,char *argv[])
  {
      write(1,"helloworld",10); 
      return 0;
  }
  ```

  

## 2.2 Linux文件io操作

### 2.2.1 open函数

- open函数说明

  - 函数功能

    - 打开文件，并得到文件描述符。

  - 函数原型

    ```c
    int open(const char *pathname, int flags);
    int open(const char *pathname, int flags, mode_t mode);
    ```

  - 头文件说明

    ```c
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    ```

  - 参数说明

    - pathname : ⽂件路径名
    - flags : 打开标志
      - O_RDONLY: 只读⽅式打开⽂件(read only)
      - O_WRONLY: 可写⽅式打开⽂件(write only)
      - O_RDWR: 读写⽅式打开⽂件(read write)
      - O_CREAT: 如果该⽂件不存在就创建⼀个新的⽂件，并⽤第三的参数为其设置权限
      - O_EXCL: 如果使⽤ O_CRATE 时⽂件存在, open() 报错（exclusive，排外的）
      - O_TRUNC: 如果⽂件已经存在，并且以读 / 写或只写成功打开, 并清零，即清空文件内容；
      - O_APPEND: 以添加的⽅式打开⽂件，在打开⽂件的同时，⽂件指针指向⽂件末尾
    - mode : 指定创建新的⽂件的默认权限

  - 返回值

    ```
    成功：返回⽂件描述符
    失败：返回-1, 并将错误编码保存到 errno
    ```

- 示例1：通过只读的⽅式打开⼀个⽂件

  ```c
  #include <stdio.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <errno.h>
  #include <unistd.h>
  #include <string.h>
  int main(int argc,char *argv[])
  {
      int fd; 
  
      if (argc != 2)
      { 
          /*
              int main(int argc, const char *argv[])
              argc:命令行传递参数的个数
              argv[0]:命令行传递的第一个参数
              argv[1]:命令行传递的第二个参数
              argv[2]:命令行传递的第三个参数
          */
          fprintf(stderr,"Usage : < %s > < pathname >\n", argv[0]);
          return -1; 
      } 
      fd = open(argv[1], O_RDONLY);
      
      if (fd == -1)
      {
          perror("Open(): ");
          return -1; 
      } 
  
      close(fd);
      return 0;
  }
  ```

- 练习：以只写的⽅式打开⽂件, 如果不存在则创建, 如果⽂件存在则截短（即清空文件内容）

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <unistd.h>
  int main(int argc,char *argv[])
  {
      int fd; 
      if(argc != 2)
      {
      	printf("Usage : %s <pathname> .\n",argv[0]);
      }
  
      fd = open(argv[1],O_WRONLY|O_CREAT|O_TRUNC,0644);
      if (fd == -1) 
      { 
      	perror("open()");
   		exit(-1);
   	} 
   	printf("fd = %d\n",fd);
   	close(fd);
   	return 0;
  }
  ```

  

- 函数错误处理与errno

  - errno 是 Linux 操作系统中⽤于存储错误编码的全局变量, 错误编码在 Linux 系统中的定义如下：

    ```c
    #define EPERM 1 
    #define ENOENT 2 
    #define ESRCH 3 
    #define EINTR 4 
    #define EIO 5 
    #define ENXIO 6 
    #define E2BIG 7 
    #define ENOEXEC 8 
    #define EBADF 9 
    #define ECHILD 10 
    #define EAGAIN 11 
    #define ENOMEM 12 
    #define EACCES 13 
    #define EFAULT 14 
    #define ENOTBLK 15 
    #define EBUSY 16
    ```


- 错误信息打印

  - 错误信息打印主要使用perror() 函数。

    - 函数头文件

      ```c
      #include <stdio.h>
      ```

    - 函数原型

      ```c
      void perror(const char *s)
      ```

    - 函数参数

      ```
      s : ⾃定义字符串参数
      ```

  - 错误信息转换主要使⽤ strerror() 函数, 具体说明如下：

    - 函数头文件

      ```c
      #include <string.h>
      ```

    - 函数原型

      ```c
      char *strerror(int errnum)
      ```

    - 函数功能

      将错误编码转换成字符串信息，并返回该字符串的地址。

    - 函数参数

      ```
      errnum : 错误编码
      ```

    - 函数返回值

      返回错误码转换之后的字符串 or “Unknown error nnn”。

    - 示例 : 使⽤ perror 函数打印 出错信息

      ```c
      #include <stdio.h>
      #include <sys/types.h>
      #include <sys/stat.h>
      #include <fcntl.h>
      int main(int argc,char *argv[])
      {
          int fd; 
          fd = open(argv[1],O_RDONLY,0644);
          if (fd == -1) 
          { 
              perror("open(): ");
              //perror(strerror(EIO));
              //将错误编码EIO转换成出错信息字符串，通过perror函数将出错信息字符串打印出来
              return -1; 
          } 
          return 0;
      }
      ```

### 2.2.2 close函数

- close函数说明

  - 函数头文件

    ```c
    #include <unistd.h>
    ```

  - 函数原型

    ```c
    int close(int fd);
    ```

  - 函数功能

    close 函数⽤于关闭⽂件，在 io 操作结束后需要关闭⽂件，释放相关资源。

  - 函数参数

    ```
    fd : ⽂件描述符
    ```

  - 函数返回值

    ```
    成功：返回0
    失败：返回-1
    ```

- 示例：将前⾯已经打开的⽂件使⽤ close 函数关闭。





