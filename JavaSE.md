1.Java开发环境的搭建

## 1.1 常用的dos命令

- 什么是dos命令？

  ```
  在DOS命令窗口中才可以输入并执行DOS命令。在最初的windows计算机中没有图形界面的，只有DOS命令窗口。也就是说通过执行DOS命令窗口可以完全完成文件的新建、编辑、保存、删除等一系列操作。
  ```

- 默认情况下DOS命令窗口打开之后，定位的位置是哪里？

  ```
  C:\Users\Administrator 这是默认的当前路径
  ```

- 在DOS命令窗口中怎么复制内容？

  ```
  win11：左键直接选中，然后右键单击一下就到剪贴板里面了。
  ```

- 切换盘符

  ```
  直接输入盘符就行
  
  c: 回车
  d: 回车
  e: 回车
  f: 回车
  
  当切换到D盘根下了，那么当前路径就是：D:\>
  当前路径是当前所在的位置。
  ```

- 切换目录

  ```
  cd 路径
  ```

  - 相对路径和绝对路径

    - 相对路径

      ```
      相对路径一定是相对于当前所在“位置”而言的。从当前所在的位置作为起点。
      死记：相对路径一定是从当前位置作为起点开始找。
      ```

    - 绝对路径

      ```
      绝对路径：在windows操作系统中凡是路径起点是盘符的都是绝对路径。
      例如：
              C:\Users\Administrator
              C:\Users
              C:\Users\Public\gakataka
              C:\Windows\System32
              D:\BaiduNetdiskDownload
              D:\course\01-开课\OneNote
              
      注意：
              cd .. 回到上级路径。
              cd \ 直接回到根路径。
                  . 一个点，代表当前路径。（cd命令用不着。以后配置环境变量的时候一个点有用处。）
      ```

      

- 清屏

  ```
  cls
  ```

- 查看当前目录下的内容

  ```
  dir
  ```

- 退出DOS命令窗口

  ```
  exit
  ```

- 删除一个或者多个文件

  ```
  del
  ```

  - 删除T1.class文件

    ```
    C:\Users\Administrator>del T1.class
    ```

  - 删除所有.class结尾的文件，支持模糊匹配

    ```
    C:\Users\Administrator>del *.class
    ```

- 查看本机的IP地址

  ```
  ipconfig（查看ip地址的配置信息。）
  
  ipconfig /all 
  该命令后面添加一个/all参数可以查看更详细的网络信息。
  这个详细信息中包括网卡 的物理地址，例如：70-8B-CD-A7-BA-25
  这个物理地址具有全球唯一性。物理地址通常叫做MAC地址。
  ```

  - 什么是IP地址？有什么用呢？

    ```
    A计算机在网络当中要想定位到（连接到）B计算机，那么必须要先知道B计算机的IP地址，IP地址也可以看做计算机在同一个网络当中的身份证号（唯一标识）。
    ```

- 查看两台计算机是否可以正常通信

  ```
  ping IP地址
  ping 域名
  ping www.baidu.com
  ping 61.135.169.121  （61.135.169.121是百度的IP地址）
  ping 61.135.169.121 -t （-t参数表示一直ping）
  一直ping的目的可以查看网络是否稳定。
  
  在一个DOS命令窗口中如果有一个命令一直在执行，想强行终止怎么办？ctrl + c 组合键
  ```

## 1.2 文本编辑快捷键

掌握常用的通用的文本编辑快捷键很重要，可以大大提升开发效率。所以，必须熟练掌握，从此刻开始强迫自己少用鼠标，用组合键快捷键的方式。

| 功能                         | 快捷键                       |
| ---------------------------- | ---------------------------- |
| 复制                         | ctrl + c                     |
| 粘贴                         | ctrl + v                     |
| 剪切                         | ctrl + x                     |
| 保存                         | ctrl + s                     |
| 撤销                         | ctrl + z                     |
| 重做                         | ctrl + y                     |
| 回到行首                     | home键                       |
| 回到行尾                     | end键                        |
| 当光标在行尾，怎么选中一行？ | shift + home键               |
| 当光标在行首，怎么选中一行？ | shift + end键                |
| 回到文件头                   | ctrl + home                  |
| 回到文件尾                   | ctrl + end                   |
| 全选                         | ctrl + a                     |
| 查找                         | ctrl + f                     |
| 选中一个单词                 | 鼠标双击                     |
| 选中一行                     | 鼠标连续击3次                |
| 不用鼠标选中一个单词         | ctrl + shift + 右箭头/左箭头 |
| 代码左缩进                   | tab键                        |
| 代码右缩进                   | shift + tab键                |

## 1.3 计算机编程语言发展史

```
第一代语言：机器语言
第二代语言：汇编语言
第三代语言：高级语言

计算机编程语言是什么？是一个团队，或者一个组织制定的一套固定的语法规则，你可以学习这套语法规则，然后通过这套语法规则和计算机交互。
我们为什么要学习汉语？原因是我们学习了汉语之后，可以完成人和人的沟通。
我们为什么要学习日语？因为我们要和日本人沟通。
```

## 1.4 Java语言的概述和发展史

- JDK

  ```
  Java开发工具箱，做Java开发必须安装的，这是最根本的一个环境，JDK不是集成开发环境，JDK这个开发工具箱中是Java最核心的库。
  ```

- 98年的时候，Java升级到JDK1.2，Java被分为三大块：

  ```
  J2SE：标准版（基础，要学java，必须先学习SE。基础语法+基础库）
  J2EE：企业版（专门为企业开发软件，为企业提供解决方案。例如：OA办公系统，保险行业的系统，金融行业的系统，医院系统....）
  J2ME：微型版（专门为微型设备做嵌入式开发的。）
  ```

- java诞生十周年的时候改了名字

  ```
  JavaSE、JavaEE、JavaME。
  ```


## 1.5 Java语言的特性

- 简单性

  ```
  在Java语言当中真正操作内存的是JVM（Java虚拟机）。所有的java程序都是运行在Java虚拟机当中的。而Java虚拟机执行过程中再去操作内存。
  
  对于C或者C++来说程序员都是可以直接通过指针操作内存的。C或者C++更灵活，可以直接程序员操作内存，但是要求程序员技术精湛。C语言或者C++更有驾驭感。
  
  Java语言屏蔽了指针概念，程序员不能直接操作指针，或者说程序员不能直接操作内存。这种方式有优点也有缺点：
  优点：不容易导致内存泄漏。（简单了。）
  缺点：效率问题，包括驾驭感比较差。
  例如飞机航行：
         如果是C语言表示程序员是飞机驾驶员。
         如果是Java语言表示程序员是飞机上的乘客。
  
  Java语言底层是C++，所以JVM是用C++语言写好的一个虚拟的电脑。
  JVM在哪里？告诉大家，安装了JDK之后，JVM就代表安装好了。
  ```

- 完全面向对象

  ```
  面向对象更容易让人理解，人类通常是以对象的方式认知世界的。采用面向对象的方式可以让复杂问题简单化。  
  ```

- 健壮性

  ```
  主要是因为Java中有一种机制：自动垃圾回收机制（GC机制）。
  java语言是健壮的，相对于C语言来说，C语言没有Java健壮。
  Java不容易导致内存的泄漏，C++或者C语言使用不当时很容易导致内存泄漏。
  
  JVM负责调度GC机制。程序员不需要干涉。
  
  以上讲解中又描述了这几个术语：
      JVM（C++语言写的一个虚拟的计算机）、GC（垃圾回收机制）
  ```

- java完全/完美支持多线程并发

- 可移植性/跨平台

  ```
  java语言只要编写一次，可以做到到处运行。
  例如：java程序编写完之后，可以运行在windows操作系统上，不需要做任何改动可以直接运行在Linux操作系统上，同样也可以运行到Mac OS上面。
  
  一次编写，到处运行。（平台改变了，程序不需要改。）
  ```

  <img src="assets/image-20240513232848877.png" alt="image-20240513232848877" style="zoom: 50%;" />

  <img src="assets/image-20240513233603073.png" alt="image-20240513233603073" style="zoom: 33%;" />

  - JVM这种机制实现了跨平台，那么这种机制优点和缺点分别是什么？

    - 优点

      ```
      一次编写到处运行，可以跨平台。
      ```

    - 缺点

      ```
      麻烦，对于运行java程序来说必须先有一个JVM。就像你要想在网页上看视频，你必须先安装一个flash是一样的。
      ```

  - Java语言可以编写病毒吗？

    ```
    可以，没问题。但是很难让用户中毒。
    中毒的一般都是java程序员。所以很少有人编写java的病毒脚本。
    ```


## 1.6 JDK、JRE、JVM三者之间的关系

```
JDK：Java开发工具箱
JRE：Java运行环境
JVM：Java虚拟机

关系：JDK包括JRE，JRE包括JVM。
```

<img src="assets/image-20240513234355118.png" alt="image-20240513234355118" style="zoom: 25%;" />

```
有单独的JDK安装包，也有单独的JRE安装包，没有单独的JVM安装包。因此JDK和JRE都是可以独立安装的，JVM是不能独立安装的。

安装JDK的时候，JRE就自动安装了，同时JRE内部的JVM也就自动安装了。
安装JRE的时候，JVM也就自动安装了。
```

- 问题：假设你在软件公司开发了一个新的软件，现在要去客户那边给客户把项目部署一下，把项目跑起来，你需要安装JDK吗？

  ```
  只需要安装JRE就行了。JRE体积很小，安装非常便捷快速。
  ```

- 问题：为什么安装JDK的时候会自带一个JRE？

  ```
  因为java程序员开发完程序之后，要测试这个程序，让这个程序运行起来，需要JRE。所以JDK安装的时候内部自带一个JRE。
  ```

## 1.7 对Java的加载与执行的理解（理论比较重要）

- java程序从编写到最终运行经历了哪些过程？

  ```
  java程序非常重要的两个阶段：编译阶段和运行阶段。
  
  注意：java程序员直接编写的java代码（普通文本）是无法执行被JVM识别的。java程序员编写的java代码这种普通文本必须经过一个编译，将这个“普通文本代码”变成“字节码”，JVM能够识别“字节码”。java代码这种普通文本变成字节码的过程，被称为：编译。
  
  java代码这种普通文本被称为：java源代码。源代码不能被JVM直接执行，需要先进行编译，生成源代码对应的“字节码”JVM可以识别的是字节码。
  ```

- 编译阶段和运行阶段可以在不同的操作系统上完成吗？

  ```
  在windows上编译，编译之后生成了“字节码”，把“字节码”放到linux上运行完全可以，因为Java是跨平台的，可以做到一次编写到处运行。    
  ```

- java源代码一旦编译之后，源代码可以删除吗？只留下字节码可以执行吗？

  ```
  完全可以执行，因为源代码不参与程序的执行过程。参与程序执行过程的是字节码。但是最好不要删除源代码。因为有可能执行结果不是你需要的，当执行结果不是你需要的时候，你可以重新打开源代码进行修改，然后重新编译生成新的字节码，再重新执行。这样会有新的执行结果。
      
  放源代码的文件扩展名必须是：xxx.java；编译生成的字节码文件扩展名是：xxx.class。
  另外需要注意的是：1个java源文件是可以编译生成多个class文件的。最终运行的是class文件。
  ```

- 字节码文件是二进制文件吗？

  ```
  字节码文件不是二进制文件。如果是二进制的话，就不需要JVM了。因为操作系统可以直接执行二进制。
  ```

- java程序从开发到最终运行经历了什么？

  - 编译期：（可以在windows上）

    ```
    第一步：在硬盘的某个位置（随意），新建一个xxx.java文件。
    第二步：使用记事本或者其它文本编辑器例如EditPlus打开xxx.java文件。
    第三步：在xxx.java文件中编写“符合java语法规则的”源代码。
    第四步：保存（一定要将xxx.java文件保存一下）。
    第五步：使用编译器（javac【JDK安装后自带】）对xxx.java文件进行编译。
    第六步：如果xxx.java文件中编写的源代码是符合语法规则的，编译会通过，如果xxx.java文件中编写的源代码违背了语法规则，那么编译器会报错，编译器报错之后class文件是不会生成的，只有编译通过了才会生成class字节码文件。并且一个java源文件是可以生成多个class文件的。（编译实质上是检查语法）
    ```

  - 运行期（JRE在起作用）：（可以在windows上，也可以在其他的OS上。）

    ```
    第七步：如果是在Linux上运行，需要将windows上生成的class文件拷贝过去，不需要拷贝源代码，真正运行的是字节码。（但是源代码也不要删除，有用）
    第八步：使用JDK自带的一个命令/工具：java（负责运行的命令/工具）执行字节码。
    第九步：往下的步骤就全部交给JVM了，就不需要程序员干涉了。JVM会将字节码文件通过类加载器装载进去，然后JVM中的解释器对字节码进行解释（解释器负责将字节码解释为1010101010..等的二进制）
    第十步：JVM会将生成的二进制码交给OS操作系统，操作系统会执行二进制码和硬件进行交互。
    ```

    ```
    注意：在以上的过程中，需要使用两个非常重要的命令，javac 命令，负责编译；java 命令，负责运行。
    
    小插曲：xxx.java源文件经过编译之后生成了A.class、B.class、C.class等文件，那么我们称A是一个类、B是一个类、C是一个类。其中A、B、C是类的名字。没有为什么，死记硬背，SUN公司的java语法就是这么规定的。
    
    以上是一个复杂的过程，那么缩减一下，程序员到底要干啥？
        新建java文件
        打开java文件
        写java源代码
        保存
        javac命令编译
        java命令运行
    总结为：编写、编译、运行
    ```

## 1.8 编写java中的第一个java程序：HelloWorld

这个程序不需要理解，主要是为了搭建java的开发环境，测试java的环境是否能用。

- 第一步：安装文本编辑器（EditPlus）

- 第二步：安装JDK（先下载JDK）

  ```
  安装JDK13，直接下一步就行。JDK13安装的时候内置了一个JRE，独立于JDK之外的JRE并没有生成。对于java13来说，如果你希望生成一个独立于JDK之外的JRE的话需要执行特殊的命令。这里先不讲，后期用到的时候再说。
  注意：JDK8安装的时候，不仅JDK内置了一个JRE，而且还会在JDK目录之外 独立的生成一个单独的JRE。（以前低版本的时候，JRE实际上是有2个。）一个是JDK内置的，一个是独立于JDK之外的。
  JDK的bin目录下有：javac.exe 负责编译、java.exe 负责运行。
  ```

- 第三步：写代码

  ```
  括号：[]、()、{}都要成对写。
  ```

- 第四步：编译

  ```
  需要使用的命令是：C:\Program Files\Java\jdk-13.0.2\bin\javac.exe。这个命令需要先测试一下，打开DOS命令窗口，看看javac命令是否可用。
  
  C:\Users\Administrator>javac
  'javac' 不是内部或外部命令，也不是可运行的程序或批处理文件。
  
  这说明：windows操作系统没有发现“javac.exe”命令在哪里。 windows操作系统没有找到javac.exe文件在哪。
  ```

  - 为什么ipconfig、ping等命令可以使用呢，为什么javac用不了？

    ```
    我们发现windows操作系统中有这样一个环境变量，名字叫做：path。
    并且发现path环境变量的值是：C:\Windows\system32;%SystemRoot%;等........
    我们还发现了在：C:\Windows\System32 这个目录下存在：ipconfig.exe
    
    注意：修改完环境变量之后，DOS命令窗口必须关闭重新打开才会起作用。
    
    将path环境变量中的:C:\windows\system32; 删除之后再测试：
    C:\Users\Administrator>ipconfig
    'ipconfig' 不是内部或外部命令，也不是可运行的程序或批处理文件。
    ```

  - 配置环境变量path的步骤：

    ```
    桌面计算机上右键-->属性-->高级系统设置-->环境变量。找到path，鼠标双击！path环境变量当中都是路径，路径和路径之间必须采用“半角的分号”分隔。为了让javac.exe能用，我们将C:\Program Files\Java\jdk-13.0.2\bin配置到path当中。
    
    注意：环境变量包括“系统变量”和“用户变量”
            系统变量：范围比较大，系统变量会让计算机所有用户都起作用。
            用户变量：范围比较小，这个变量只是作用于当前用户。
    ```

  - 怎么查看编译器版本？

    ```
    C:\Users\Administrator>javac -version
    javac 13.0.2    
    ```

  - 怎么查看java虚拟机的版本？

    ```
    C:\Users\Administrator>java -version
    java version "13.0.2" 2020-01-14
    Java(TM) SE Runtime Environment (build 13.0.2+8)
    Java HotSpot(TM) 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)
    ```

  - 问题1：path环境变量的作用是什么？

    ```
    path环境变量的作用就是给windows操作系统指路的。告诉windows操作系统去哪里找这个命令文件。path环境变量中有很多很多的路径，路径和路径之间用半角分号分隔。
    
    path=A;B;C;D......。path是环境变量的名字。A;B;C;D......是环境变量path的值。
    ```

  - 问题2：path环境变量是java中的机制，还是windows操作系统中的机制？

    ```
    path环境变量本质上是隶属于windows操作系统的，和java没有关系。java只不过用了一下path环境变量。
            
    要学会融会贯通，学一通百。以后在安装其他软件之后，希望在DOS命令窗口中使用该软件的某个命令的时候，如果出现“命令找不到错误了”，这个时候希望大家能够想起来配置环境变量path。
    ```

  - javac命令用法：

    ```
    javac java源文件的路径
    ```

- 第五步：运行

  ```
  运行的前提是：class文件（字节码）生成了。没有字节码文件程序是无法运行的。
  使用JDK的bin目录下的java.exe命令来运行。先在DOS命令窗口中测试java.exe这个命令是否可用！java -version
  ```

  - java命令用法：

    ```
    java 类名
    
    注意：java这个命令，后面跟的是“类名”，而绝对不能跟“文件路径”。
        对于这个字节：Test.class，应该：java Test
        对于这个字节码：A.class ，应该 java A
        对于这个字节码：Hello.class，应该java Hello
    
    运行java程序的步骤：
    第一步（必须这样做，这是必须的，先记住）：先使用cd命令切换到Test.class文件所在的路径。
    第二步：执行java Test。
    ```

## 1.9 到目前为止我们一共配置了哪些环境变量？

```
到目前为止，我们只配置了一个环境变量path，并且这个环境变量path和java实际上没关系，是人家windows操作系统的机制。

对于Java的JDK所属的环境变量，有一个叫做：JAVA_HOME，目前我们不需要配置，不配置这个环境变量也不会影响当前java程序的运行。但是后期学习到JavaWEB的时候需要安装Tomcat服务器，那个时候JAVA_HOME就必须配置了。

那么除了JAVA_HOME环境变量之外，JDK相关的环境变量还有classpath。
```

## 1.10 “java HelloWorld”的执行过程以及原理

- java HelloWorld 敲完回车，都发生了什么？

  - 第一步：会先启动JVM（java虚拟机）

  - 第二步：JVM启动之后，JVM会去启动“类加载器classloader”

    ```
    类加载器的作用：加载类的。本质上类加载器负责去硬盘上找“类”对应的“字节码”文件。
    假设是“java HelloWorld”，那么类加载器会去硬盘上搜索：HelloWorld.class文件。
    假设是“java Test”，那么类加载器会去硬盘上搜索：Test.class文件。
    ```

  - 第三步：

    ```
    类加载器如果在硬盘上找不到对应的字节码文件，会报错（错误: 找不到或无法加载主类）。
    类加载器如果在硬盘上找到了对应的字节码文件，类加载器会将该字节码文件装载到JVM当中，JVM启动“解释器”将字节码解释为“101010000...”这种二进制码，操作系统执行二进制码和硬件交互。
    ```

- 默认情况下，类加载器去硬盘上找“字节码”文件的时候，默认从哪找？

  ```
  默认情况下类加载器（classloader）会从当前路径下找。  
  ```

- 能不能给类加载器指定一个路径，让类加载器去指定的路径下加载字节码文件？

  ```
  可以的。但是我们需要设置一个环境变量，叫做：classpath；  
  classpath是一个环境变量，是给“类加载器”指路的；
  classpath环境变量不属于windows操作系统，classpath环境变量隶属于java。
  classpath环境变量是java特有的。
          classpath=A路径;B路径;C路径.....
          classpath是一个变量名
          A路径;B路径;C路径.....是变量值
  ```

- 配置classpath环境变量：

  ```
  计算机-->右键-->属性-->高级系统设置-->环境变量-->新建...
      
  注意：变量名不能随意写：大小写无所谓，但必须叫做：classpath
  
  例如：随意配置classpath=D:\course，重启CMD。
  
  配置了classpath=D:\course之后，类加载器只会去D:\course目录下找“xxx.class”文件，不再从当前路径下找了。
          
  结论是：到目前为止，classpath环境变量不需要配置。但必须理解classpath环境变量是干什么的。   
  ```

- classpath环境变量的作用是什么？

  ```
  是给类加载器指路的。
  在没有配置环境变量classpath的时候，默认从当前路径下加载。
  如果配置了环境变量classpath的话，就只能从指定的路径下加载了。
  ```

## 1.11 JDK13新特性

```
注意：了解即可，不需要掌握，现阶段也不需要这样写。

在高版本的JDK当中，有这样的一个新特性，可以直接这样一步到位：
    java x/y/z/xxx.java（java后面直接加java源文件的路径）。

这个特性是为了简化开发而提出，但实际上底层的实现原理还是和以前一样的，以上命令在执行过程中，还是会先进行编译，然后再运行。并且以上的运行方式，编译生成的class文件在硬盘上不存在，看不到。
```

## 1.12 Java中的注释

```
// 单行注释

/*
   多行注释
*/

/**
* javadoc注释：这里的注释信息可以自动被javadoc.exe命令解析提取并生成到帮助文档当中。
*/
```

- 注释是对java源代码的解释说明。注释可以帮程序员更好的理解程序。

- 注释信息只保存在java源文件当中，java源文件编译生成的字节码class文件，这个class文件中是没有这些注释信息的。

- 在实际的开发中，一般项目组都要求积极的编写注释。这也是一个java软件工程师的基本素养。

## 1.13 一些注意事项

- 在java中任何有效的代码必须写到“类体”当中，最外层必须是一个类的定义。

- public表示公开的，class表示定义一个类，后跟的是一个类名。类名后面必须是一对大括号，这一对大括号被称为“类体”

- main方法（程序的入口，SUN公司java语言规定的），JVM在执行程序的时候，会主动去找这样一个方法。没有这个规格的方法，程序是无法执行的。任何一个程序都要有一个入口，没有入口进不来，无法执行。

  - 如果完全不写main方法，编译能通过，但是无法运行。

  - main方法前的public不能丢，若丢了public，编译能通过，但是无法运行。

  - args可以改名字，随意，对于主方法来说只有这个位置可以改，其它位置不能动。

  - main方法中什么都不写也可以编译通过并运行。

  - 任何方法必须放到“类体”中，不能放到“类体”外面。

  - 类体当中应该是方法，而不是直接的java语句，否则编译直接报错。

## 1.14 一些结论

- 一个java源文件中可以定义多个class。

- 在源文件中只要有一个class的定义，那么必然会对应生成一个class文件。

- public的类不是必须的，可以没有，但如果有的话，public修饰的类名必须和源文件名保持一致。public的类有也只能有1个。

# 2.Java中的标识符与关键字

## 2.1 标识符

- 标识符可以标识什么，什么是标识符？

  ```
  可以标识：类名、方法名、变量名、接口名、常量名……等。
  凡是程序员自己有权利命名的单词都是标识符。
  ```

- 标识符的命名规则（命名规则属于语法机制，必须遵守，不遵守命名规则表示不符合语法，这样编译器会报错）。
  - 标识符只能由数字、字母（包括中文）、下划线_、美元符号$组成，不能含有其它符号。
  - 标识符不能以数字开头。
  - 关键字不能做标识符。例如：public class static void 都是关键字，关键字是不能做标识符的。
  - 标识符是严格区分大小写的。大写A和小写a不一样。
  - 标识符理论上是没有长度限制的。

- 标识符的命名规范

  - 见名知意；

  - 遵循驼峰命名方式：
    - 类名和接口名首字母大写，后面每个单词首字母大写。如StudentTest、UserTest。
    - 变量名和方法名首字母小写，后面每个单词首字母大写。如studentAge，userName。

  - 所有“常量”名：全部大写，并且单词和单词之间采用下划线衔接。

    ```
    USER_AGE ：用户年龄
    MATH_PI：固定不变的常量3.1415926.....
    ```

## 2.2 关键字

- 什么是关键字？

  ```
  在SUN公司开发Java语言的时候，提前定义好了一些具有特殊含义的单词，这些单词全部小写，具有特殊含义，不能用作标识符。
  注意：java语言中是严格区分大小写的。public和Public不一样。Class和class不一样。static和Static也不一样。
  ```

- 那么关键字有哪些呢，我们需要背会吗？需要单独去记忆吗？

  ```
  关键字：public、static、void、class、byte、short、int、long、float、double、boolean、char、true、false、if、while、for、private、protected........
  
  对于这些关键字来说不需要单独花费时间去记忆，随着后面程序的积累，会接触到所有的关键字。
  ```

# 3.Java中的变量

## 3.1 字面量

- 开发软件是为了解决现实世界中的问题。而现实世界当中，有很多问题都是使用数据进行描述的。所以软件执行过程中最主要就是对数据的处理。软件在处理数据之前需要能够表示数据，在java代码中使用字面量来表示数据。
- 在java语言中“数据”被称为“字面量”。例如：10、1.23、true、false、'a'、"abc"。以上这些都是数据，在程序中都被叫做“字面量”。
- 字面量可以分为很多种类：
  - 整数型字面量：1 2 3 100 -100 -20 ....
  - 浮点型字面量：1.3 1.2 3.14.....
  - 布尔型字面量：true、false
  - 字符型字面量：'a'、'b'、'中'
  - 字符串型字面量："abc"、"a"、"b"、"中国"。
- 其中字符型和字符串型都是描述了现实世界中的文字。
- 需要注意的是：所有的字符型只能使用单引号括起来，所有的字符串型只能使用双引号括起来。字符型一定是单个字符才能成为“字符型”。在语法级别上区分字符型和字符串型的方法是主要看是双引号还是单引号。单引号的一定是字符型。双引号的一定是字符串型。

## 3.2 变量

- 变量的概念
  - 变量其实就是内存当中存储数据的最基本的单元，变量就是一个存储数据的盒子。

- 数据类型的作用
  - 在java语言当中任何数据都是有数据类型的，如byte、short、int、long、float、double、boolean、char。
  - 不同的数据类型，在内存中分配的空间大小不同。也就是说，Java虚拟机到底给这个数据分配多大的空间，主要还是看这个变量的数据类型。根据不同的类型，分配不同大小的空间。

- 变量的三要素

  - 变量的三要素为：变量的数据类型、变量的名字、变量中保存的值。
  - 类型决定空间的大小。
  - 起个名字是为了以后方便访问。（以后在程序中访问这个数据是通过名称来访问的，变量名属于标识符）。
  - 值是变量保存的数据。

- 变量声明/定义的语法格式

  - 数据类型 变量名;

    ```
    例如：int userAge;
    ```

- 变量的赋值

  - 在java语言中有一个规定，变量必须先声明，再赋值才能访问（没有值相当于这个空间没有开辟）。
  - 在java语言中使用一个运算符，叫做“=”，这个运算符被称为赋值运算符。
  - 赋值运算符“=”的运算特点是：等号右边先执行，执行完之后赋值给左边的变量。
  - 变量可以一边声明一边赋值，如：String userName = "Joker";

- 变量的分类（“死记硬背”）

  - 变量根据出现的位置进行划分：
    - 在方法体当中声明的变量：局部变量。
    - 在方法体之外，类体内声明的变量：成员变量。
  - 重点依据是：声明的位置。
  - 注意：局部变量只在方法体当中有效，方法体执行结束该变量的内存就释放了。
- 变量的作用域
  - 变量的作用域是指：变量的有效范围。
  - 关于变量的作用域，可以记住一句话：出了大括号就不认识了。（死记这句话。）
  - java中有一个很重要的原则：
    - 就近原则。（不仅java中是这样，其它编程语言都有这个原则。）
    - 哪个离我近，就访问哪个。

- 一些注意事项

  - 方法体中的代码遵循自上而下的顺序执行。
  - 在同一个域当中，变量名不能重名、不能重复声明。
  - 可以一行声明多个变量。

# 4.Java中的数据类型

## 4.1 数据类型

- 数据类型的作用

  - 数据类型用来声明变量，程序在运行过程中根据不同的数据类型分配不同大小的空间。

    ```
    例如：
    int i = 10;        
    double d = 1.23;        
    // i变量和d变量类型不同，空间大小不同。
    ```

- 数据类型在Java中包括两种

  - 基本数据类型（4大类，8小种）

    - 整数型

      ```
      byte,short,int,long （没有小数的） 
      ```

    - 浮点型

      ```
      float,double （带有小数的）
      ```

    - 布尔型

      ```
      boolean
      只有两个值true和false，true表示真，false表示假
      ```

    - 字符型

      ```
      char
      java中规定字符型字面量必须使用单引号括起来。属于文字。
      ```

  - 引用数据类型

    - 字符串型String属于引用数据类型，String字符串不属于基本数据类型范畴。
    - java中除了基本数据类型之外，剩下的都是引用数据类型。引用数据类型后期面向对象的时候才会接触。

- 各数据类型当中的区别

  - 整数型byte short int long有什么区别，浮点型float和double有什么区别？占用的空间大小不同。

    | **类型** | **占用字节数量（Byte）** |
    | -------- | ------------------------ |
    | byte     | 1                        |
    | short    | 2                        |
    | int      | 4                        |
    | long     | 8                        |
    | float    | 4                        |
    | double   | 8                        |
    | boolean  | 1                        |
    | char     | 2                        |

  - 关于计算机的存储单位

    ```
    1B = 8b
    1KB = 1024Byte = 2^10B
    1MB = 1024KB = 2^20B
    1GB = 1024MB = 2^30B
    1TB = 1024GB = 2^40B
    =========================================================================================
    byte b = 2; 在计算机中是这样表示的：												00000010
    short s = 2; 在计算机中是这样表示的：									00000000 	00000010
    int i = 2;在计算机中是这样表示的：				00000000 	00000000 	00000000 	00000010
    ……
    ```

- 必须熟记的几个取值范围

  - short和char实际上容量相同，不过char可以表示更大的数字。因为char表示的是文字，文字没有正负之分，所以char可以表示更大的数字。

    | byte  | -128 ~ 127                                  |
    | ----- | ------------------------------------------- |
    | short | -32768 ~ 32767（可以表示65536个不同的数字） |
    | int   | -2147483648 ~ 2147483647                    |
    | char  | 0~65535（可以表示65536个不同的数字）        |

- 字符编码

  - 对于8种基本数据类型来说：其中byte,short,int,long,float,double,boolean，这7种类型计算机表示起来比较容易，因为他们都是数字。其中布尔类型只有两个值true和false，实际上true和false分别在C++中对应的是1和0，1为true，0为false。

  - 对于char类型来说计算机表示起来比较麻烦，因为char对应的是文字，每一个国家的文字不一样，文字不能直接通过“自然算法”转换成二进制。这个时候怎么办？字符编码诞生了。

  - 字符编码是人为的定义的一套转换表。在字符编码中规定了一系列的文字对应的二进制。字符编码其实本质上就是一本字典，该字典中描述了文字与二进制之间的对照关系。字符编码是人为规定的。（是某个计算机协会规定的。）

  - 字符编码涉及到编码和解码两个过程，编码和解码的时候必须采用同一套字符编码方式，不然就会出现乱码。

  - 关于字符编码的发展过程：

    - 起初的时候计算机是不支持文字的，只支持科学计算。实际上计算机起初是为了战争而开发的，计算导弹的轨道....后来随着计算机的发展，计算机开始支持文字，最先支持的文字是英文，英文对应的字符编码方式是：ASCII码。ASCII码采用1byte进行存储，因为英文字母是26个。（键盘上所有的键全部算上也超不过256个。1byte可以表示256种不同的情况。所以英文本身在计算机方面就占有优势。）

      ```
      'a' --(采用ASCII码进行编码)-> 01100001
       01100001 --(采用ASCII码进行解码)-> 'a'
      ```

    - 如果编码和解码采用的不是同一个编码方式，会出现乱码。随着计算机语言的发展，后来国际标准组织制定了ISO-8859-1编码方式，又称为latin-1编码方式，向上兼容ASCII码，但不支持中文，后来发展到亚洲，才支持中文，日文，韩文....

    - 中文这块的编码方式：GB2312<GBK<GB18030 （容量的关系），这三种编码方式是简体中文。

      - 繁体中文：big5（台湾使用的是大五码。）

  - 在java中，java语言为了支持全球所有的文字，采用了一种字符编码方式叫做unicode编码。unicode编码统一了全球所有的文字，支持所有文字。UTF表示Unicode 转换格式，具体的实现包括：UTF-8 UTF-16 UTF-32....

## 4.2 原码、反码、补码

- 计算机中实际只存储补码。

- 正数的原码=反码=补码；

- 负数的如下计算：

  - 原码→反码：符号位不变，其余取反。

  - 反码→补码：反码+1。

    ```
    byte b = (byte)150; 这个b是多少？
    int类型的4个字节的150的二进制码是：
        00000000 00000000 00000000 10010110
    将以上的int类型强制类型转为1个字节的byte即砍掉前三个字节，最终在计算机中的二进制码是：
        10010110
    千万要注意：计算机永远存储的都是二进制补码形式。也就是说上面10010110 这个是一个二进制补码形式，你可以采用逆推导的方式推算出这个二进制补码对应的原码是啥！
        10010110 → 二进制补码形式
        10010101 → 二进制反码形式
        11101010 → 二进制原码形式 即-106
    ```

## 4.3 八种基本数据类型详解

- 字符型 char
  - char类型的字面量是使用单引号括起来的单个字符，char可以存储一个汉字。
  - 当一个整数赋值给char类型变量的时候，会自动转换成char字符型，最终的结果是一个字符。

- 整数型 byte short int long

  - 重要结论（熟记）：在任何情况下，整数型的“字面量/数据”默认被当做int类型处理。如果希望该“整数型字面量”被当做long类型来处理，需要在“字面量”后面添加L/l，建议使用大写L，因为小写l和1傻傻分不清。

  - 如果整数型字面量没有超出 byte,short,char 的取值范围，可以直接将其赋值byte,short,char 类型的变量；

- 浮点型 float double

  - 重要结论（熟记）：在任何情况下，浮点型的“字面量/数据”默认被当做double类型处理。如果希望该“浮点型字面量”被当做float类型来处理，需要在“字面量”后添加F/f。

  - 虽然long类型占用8个字节，float类型占用4个字节。但任意一个浮点型都比整数型容量大。

  - 小容量向大容量转换称为自动类型转换，容量从小到大的排序为：

    - byte < short(char) < int < long < float < double，其中 short和 char 都占用两个字节，但是char 可以表示更大的正整数；

    - 大容量转换成小容量，称为强制类型转换，编写时必须添加“强制类型转换符”，但运行时可能出现精度损失，谨慎使用；

- 布尔型 boolean
  - 在java语言中boolean类型只有两个值，没有其他值：true和false。不像C或者C++，C语言中1和0也可以表示布尔类型。 
  - boolean类型在实际开发中使用在逻辑判断当中，通常放到条件的位置上（充当条件）。
  - 八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以进行转换；

## 4.4 综合的看一下，在类型转换的时候需要遵循哪些规则

- 八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以进行转换；


- 如果整数型字面量没有超出 byte,short,char 的取值范围，可以直接将其赋值给byte,short,char 类型的变量；


- 小容量向大容量转换称为自动类型转换，容量从小到大的排序为：

  - byte < short(char) < int < long < float < double，其中 short和 char 都占用两个字节，但是char 可以表示更大的正整数；

- 大容量转换成小容量，称为强制类型转换，编写时必须添加“强制类型转换符”，但运行时可能出现精度损失，谨慎使用；


- 多种数据类型混合运算，各自先转换成容量最大的那一种再做运算，但是byte,short,char 类型混合运算时，先各自转换成 int 类型再做运算；


所有的笔试题都超不出以上的5条规则。死记硬背。

```
注： 
①byte a = 10;
// 编译不会报错，因为编译器知道10是一个未超过byte范围的整型字面量。

②int a = 10; byte b = a; 
// 编译会报错类型不兼容，因为在第二个语句中编译器只知道a是一个整型变量，并不知道a具体的值，实际的值只有在运行时才知道。   

例如：byte a = 3;
这行代码为什么可以编译通过呢？
按说 3 是 int 类型，而 a 变量是 byte 类型，大容量转换成小容量不是应该使用强制类型转换符吗，这里没有使用，也可以编译通过。
这是因为 Java 中固定的语法规则规定的，当一个整数字面量没有超出 byte 类型取值范围时，可以直接赋值给 byte 类型的变量，其实这一设计也是为了方便程序员写代码。
另外，我们如果基于以上代码再添加这行代码：byte b = a + 4;这行代码为什么又编译报错了呢？
按说 a 是 3，3+4 是 7，这个 7 并没有超出 byte 取值范围，为什么编译报错呢？
这是因为 byte 类型的 a 和 int 类型的 4 求和，结果为 int 类型，并且对于以上代码来说 a 是一个变量，变量就是一个不确定的值，所以编译器会认为 a + 4 可能会超出 byte 取值范围，所以编译报错了。
如果我们程序是这样写的：byte b = 3 + 4;对于这行代码来说，编译又通过了，这是因为 3和 4 不是变量，都是确定的值，编译器会直接检测出 3+4 等于 7，这个 7 并没有超出范围，所以编译又通过了。
```

# 5.Java中的运算符

- 算术运算符

  ```
  +    -    *    /    %    ++    --
  ```

- 关系运算符

  ```
  >    >=    <    <=    ==    != 
  一定要记住一个规则：所有的关系运算符的运算结果都是布尔类型，不是true就是false，不可能是其他值。
  ```

- 逻辑运算符

  | &    | 逻辑与 |
  | ---- | ------ |
  | \|   | 逻辑或 |
  | !    | 逻辑非 |
  | &&   | 短路与 |
  | \|\| | 短路或 |

  - 逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型。
  - 短路与&& 和 逻辑与&有什么区别？
    - 首先这两个运算符的运算结果没有任何区别，完全相同。只不过“短路与&&”会发生短路现象。右边表达式不执行，这种现象叫做短路现象。
  - 什么时候使用&&，什么时候使用& ？
    - 从效率方面来说，&&比&的效率高一些。因为逻辑与&不管第一个表达式结果是什么，第二个表达式一定会执行。
    - 以后的开发中，短路与&&和逻辑与还是需要同时并存的。大部分情况下都建议使用短路与&&，只有当既需要左边表达式执行，又需要右边表达式执行的时候，才会选择逻辑与&。

- 赋值运算符

  ```
  =        +=        -=        *=        /=        %=
  ```

  - 赋值运算符包括“基本赋值运算符”和“扩展赋值运算符”。

    - 基本赋值运算符： =


    - 扩展的赋值运算符：+=        -=        *=        /=        %=
    
      - 注意：扩展赋值运算符在编写的时候，两个符号之间不能有空格。
    
      - 很重要的语法机制：使用扩展赋值运算符的时候，永远都不会改变运算结果类型。


      ```
      例1：byte x = 100;  x += 1;
      x自诞生以来是byte类型，那么x变量的类型永远都是byte。不会变。不管后面是多大的数字。
      
      例2：x += 1 和 x = x + 1 其实不一样：
      byte x = 100; // 100没有超出byte类型取值范围，可以直接赋值
      //x = x + 1; // 编译器检测到x + 1是int类型，报错: 不兼容的类型: 从int转换到byte可能会有损失
       x += 1; // 使用扩展赋值运算符可以就可以编译通过顺利运行
      所以得出结论：x += 1 和 x = x + 1不一样。其实 x += 1 等同于：x = (byte)(x + 1);
      ```

- 三目运算符

  - 语法格式：布尔表达式 ? 表达式1 : 表达式2
    - 注意：冒号左右表达式数据类型相一致。

  - 执行原理：
    - 布尔表达式的结果为true时，表达式1的执行结果作为整个表达式的结果。
    - 布尔表达式的结果为false时，表达式2的执行结果作为整个表达式的结果。

- 字符串连接运算符

  - +运算符在java语言中有两个作用。
    - 作用1：求和
    - 作用2：字符串拼接

  - 什么时候求和？什么时候进行字符串的拼接呢？

    - 当 + 运算符两边都是数字类型的时候，求和。
    - 当 + 运算符两边的“任意一边”是字符串类型，那么这个+会进行字符串拼接操作。
  - 一定要记住：字符串拼接完之后的结果还是一个字符串。

# 6.Java中的控制语句

## 6.1 怎么接受用户键盘输入

```java
java.util.Scanner s = new java.util.Scanner(System.in);

// 接收整数
int i = s.nextInt()

// 接收字符串
String str = s.next();
```

## 6.2 控制语句

### 6.2.1 选择语句

- if语句

  - 语法格式1：

    ```
    if(布尔表达式){
    	java语句;
    	java语句;
    }
    这里的一个大括号{} 叫做一个分支。
    ```

    - 执行原理：如果布尔表达式的结果是true，则执行大括号中的程序，否则大括号中代码不执行。

  - 语法格式2：

    ```
    if(布尔表达式){    // 分支1
        java语句;   
    }else{           // 分支2
        java语句;
    }
    ```

    - 执行原理：如果布尔表达式的结果是true，则执行分支1，分支2不执行。如果布尔表达式的结果是false，分支1不执行，执行分支2.以上的这个语句可以保证一定会有一个分支执行。

  - 语法格式3：

    ```
    if(布尔表达式1){     // 分支1
    	java语句;
    }else if(布尔表达式2){ // 分支2
    	java语句;
    }else if(布尔表达式3){
    	java语句;
    }else if(布尔表达式4){
    	java语句;
    }
    ....
    ```

    - 执行原理：先判断“布尔表达式1”，如果“布尔表达式1”为true，则执行分支1，然后if语句结束了。当“布尔表达式1”结果是false，那么会继续判断布尔表达式2的结果，如果布尔表达式2的结果是true，则执行分支2，然后整个if就结束了。从上往下依次判断，主要看第一个true发生在哪个分支上。第一个true对应的分支执行，只要一个分支执行，整个if结束。

  - 语法格式4：

    ```
    if(布尔表达式1){     // 分支1
    	java语句;
    }else if(布尔表达式2){ // 分支2
    	java语句;
    }else if(布尔表达式3){
    	java语句;
    }else if(布尔表达式4){
    	java语句;
    }else{
    	java语句; // 以上条件没有一个成立的。这个else就执行了。
    }
    ```

  - 注意：

    - 对于if语句来说，在任何情况下只能有1个分支执行，不可能存在2个或者更多个分支执行。if语句中只要有1个分支执行了，整个if语句就结束了。（对于1个完整的if语句来说的。）  
    - 以上4种语法机制中，凡是带有else分支的，一定可以保证会有一个分支执行。以上4种当中，第一种和第三种没有else分支，这样的语句可能会导致最后一个分支都不执行。第二种和第四种肯定会有1个分支执行。
    - 当分支当中“java语句;”只有1条，那么大括号{}可以省略，但为了可读性，最好不要省略。（有的程序员在编写代码的时候，可能会故意将大括号{}省略，你能看懂就行。）
    - 控制语句和控制语句之间是可以嵌套的，但是嵌套的时候我们最好一个语句一个语句进行分析，不要冗杂在一起分析。

    

- switch语句

  - switch语句也是选择语句，也可以叫做分支语句。

  - 语法格式：

    ```
    switch(值){
        case 值1:
            java语句;
            java语句;...
        	break;
        case 值2:
            java语句;
            java语句;...
            break;
        case 值3:
            java语句;
            java语句;...
            break;
        default:
        	java语句;
    }
    ```

    - 以上是一个完整的switch语句，其中break;语句不是必须的。default分支也不是必须的。

  - switch语句支持的值有哪些？
    - 支持int类型以及String类型。但一定要注意JDK的版本，JDK8之前不支持String类型，只支持int。在JDK8之后，switch语句开始支持字符串String类型。switch语句本质上是只支持int和String，但是byte,short,char也可以使用在switch语句当中，因为byte short char可以进行自动类型转换。
    - switch语句中“值”与“值1”、“值2”比较的时候会使用“==”进行比较。

  - switch语句的执行原理：
    - 拿“值”与“值1”进行比较，如果相同，则执行该分支中的java语句，然后遇到"break;"语句，switch语句就结束了。如果“值”与“值1”不相等，会继续拿“值”与“值2”进行比较，如果相同，则执行该分支中的java语句，然后遇到break;语句，switch结束。若所有的case都没有匹配成功，那么最后default分支会执行。
    - 注意：如果分支执行了，但是分支最后没有“break;”，此时会发生case穿透现象。

### 6.2.2 循环语句

在现实世界当中，有很多事情都是需要反复/重复的去做。对应到程序当中，如果有一块代码需要重复执行，此时为了减少代码量，我们使用循环语句。

- for循环

  - 语法格式：

    ```
    for(初始化表达式; 条件表达式; 更新表达式){
            循环体; // 循环体由java语句构成
            java语句;
            java语句;
            java语句;
            java语句;
            ....
    }
    ```

  - 执行原理：

    - 先执行初始化表达式，并且初始化表达式只执行1次。然后判断条件表达式的结果，如果条件表达式结果为true，则执行循环体。循环体结束之后，执行更新表达式。更新完之后，再判断条件表达式的结果，如果还是true，继续执行循环体。直到更新表达式执行结束之后，再次判断条件时，条件为false，for循环终止。
    - 更新表达式的作用是：更新表达式会更新某个变量的值，这样条件表达式的结果才有可能从true变成false，从而终止for循环的执行，如果缺少更新表达式，很有可能会导致死循环。

  - 注意：

    - 初始化表达式最先执行，并且在整个循环中只执行一次。

    - 条件表达式结果必须是一个布尔类型，也就是：true或false

- while循环

  - 语法格式：

    ```
    while(布尔表达式){
    	循环体;
    }
    ```

  - 执行原理：

    - 判断布尔表达式的结果，如果为true就执行循环体，循环体结束之后，再次判断布尔表达式的结果，如果还是true，继续执行循环体，直到布尔表达式结果为false，while循环结束。

- do..while..循环

  - 语法格式：

    ```
    do {
    	循环体;
    }while(布尔表达式);
    ```

  - 执行原理：

    - 先执行循环体当中的代码，执行一次循环体之后，判断布尔表达式的结果，如果为true，则继续执行循环体，如果为false循环结束。

      - 对于do..while循环来说，循环体至少执行1次。循环体的执行次数是：1~n次。

      - 对于while循环来说，循环体执行次数是：0~n次。

  - 注意：do..while循环最后的时候别漏掉“分号”

# 7.Java中的方法

## 7.1 方法

### 7.1.1 什么是方法，有什么用？

- 方法（method）是可以完成某个特定功能的并且可以被重复利用的代码片段。在C语言中，方法被称为“函数”。在java中不叫函数，叫做方法。

- 假设你定义了一个/抽取了一个方法出来，而这个方法却无法完成某个功能，那么你抽取的这个方法毫无意义。一般一个方法就是一个“功能单元”。假设在以后的开发中，某个功能是可以独立抽取出来的，建议定义为方法，这样以后只要需要这个功能，那么直接调用这个方法即可，而不需要重复编写业务逻辑代码。

### 7.1.2 方法怎么定义，语法机制是什么？

- 格式

  ```
  [修饰符列表] 返回值类型 方法名(形式参数列表){
      方法体; 
  }
  ```

  - 注意：
    - [] 符号叫做中括号，以上中括号[]里面的内容表示不是必须的，是可选的。
    - 方法体由Java语句构成。
    - 方法定义之后需要去调用，不调用是不会执行的。

- 关于修饰符列表：
  - 修饰符列表不是必选项，是可选的。目前为止，大家统一写成：public static，后面你就理解应该怎么写了。

- 关于返回值类型：
  - 返回值类型可以是任何类型，只要是java中合法的数据类型就行，数据类型包括基本数据类型和引用数据类型，也就是说返回值类型可以是：byte short int long float double boolean char String......
  - 什么是返回值？
    - 返回值一般指的是一个方法执行结束之后的结果。结果通常是一个数据，所以被称为“值”，而且还叫“返回值”。方法就是为了完成某个特定的功能，方法结束之后大部分情况下都是有一个结果的，而体现结果的一般都是数据。数据得有类型。这就是返回值类型。
    - 当一个方法执行结束不返回任何值的时候，返回值类型也不能空白，必须写上void关键字。所以void表示该方法执行结束后不返回任何结果。
    - 如果返回值类型“不是void”，那么你在方法体执行结束的时候必须使用 "return 值;"这样的语句来完成“值”的返回，如果没有“return 值;”这样的语句那么编译器会报错。return 值; 这样的语句作用是“返回值”，返回方法的执行结果。
    - 只要有“return”关键字的语句执行，当前方法必然结束。return只要执行，当前所在的方法结束，记住：不是整个程序结束。
    - 如果返回值类型是void，那么在方法体当中不能有“return 值;”这样的语句。但是可以有“return;”语句。这个语句“return;”的作用就是用来终止当前方法的。
    - 除了void之外，剩下的都必须有“return 值;”这样的语句。

- 关于方法名

  - 方法名要见名知意。（驼峰命名方式）

  - 方法名在标识符命名规范当中，要求首字母小写，后面每个单词首字母大写。

  - 只要是合法的标识符就行。

- 关于形式参数列表

  - 形式参数列表中的每一个参数都是“局部变量”，方法结束之后内存释放。形参的个数是：0~N个。

  - 形参有多个的话使用“逗号,”隔开。逗号是英文的。

  - 形参的数据类型起决定性作用，形参对应的变量名是随意的。

- 关于方法体

  - 方法体由Java语句构成。java语句以“;”结尾。

  - 方法体当中编写的是业务逻辑代码，完成某个特定功能。

  - 在方法体中的代码遵循自上而下的顺序依次逐行执行。

  - 在方法体中处理业务逻辑代码的时候需要数据，数据来源就是这些形参。

  - 在同一个域当中，"return语句"下面不能再编写其它代码。编写之后编译报错。

### 7.1.3 方法定义之后怎么调用呢？

- 方法必须调用才能执行。

- 调用的语法格式：类名.方法名(实际参数列表);
- 实参和形参的类型必须一一对应，另外个数也要一一对应。

### 7.1.4 方法执行过程中的内存变化

- 局部变量：只在方法体中有效，方法结束之后，局部变量的内存就释放了。

- JVM三块主要的内存：栈内存、堆内存、方法区内存。

  - 方法区最先有数据：方法区中放代码片段。存放class字节码。

  - 堆内存：后面讲。

  - 栈内存：方法调用的时候，该方法需要的内存空间在栈中分配。方法不调用是不会在栈中分配空间的。方法只有在调用的时候才会在栈中分配空间，并且调用时就是压栈。方法执行结束之后，该方法所需要的空间就会释放，此时发生弹栈动作。

    - 方法调用叫做：压栈。分配空间

    - 方法结束叫做：弹栈。释放空间

    - 栈中存储什么？方法运行过程中需要的内存，以及栈中会存储方法的局部变量。

    ```
    public class MethodTest08{
    	//主方法，入口
    	public static void main(String[] args){
    		
    		//int a = 100;
    		// 这个赋值原理是：将a变量中保存的100这个数字复制一份传给b变量。
    		// 所以a和b是两个不同的内存空间，是两个局部变量。
    		//int b = a;
    
    		System.out.println("main begin");
    		int x = 100;
    		m1(x);
    		System.out.println("main over");
    	}
    	public static void m1(int i){ // i是局部变量
    		System.out.println("m1 begin");
    		m2(i);
    		System.out.println("m1 over");
    	}
    	public static void m2(int i){
    		System.out.println("m2 begin");
    		m3(i);
    		System.out.println("m2 over");
    	
    	}
    	public static void m3(int i){
    		System.out.println("m3 begin");
    		System.out.println(i);
    		System.out.println("m3 over");
    	}
    }
    ```

    ![image-20240531155503225](assets/image-20240531155503225.png)

## 7.2 方法重载

### 7.2.1 什么情况下我们考虑使用方法重载机制？

- 当功能相似的时候，建议将方法名定义为一致的，这样代码美观，又方便编程。
- 注意：如果功能不相似，坚决要让方法名不一致。

### 7.2.2 代码满足什么条件的时候构成了方法重载？

- 条件1：在同一个类当中
- 条件2：方法名相同
- 条件3：形式参数列表不同（类型、个数、顺序）
- 注意：方法重载和返回值类型无关，和修饰符列表无关。

### 7.2.3 方法重载的优点

- 代码美观，方便代码的编写。

## 7.3 方法递归

### 7.3.1 什么是方法递归？

- 方法自身调用自身。

### 7.3.2 使用递归的时候，必须添加结束条件

- 没有结束条件，会发生栈内存溢出错误(StackOverflowError)
- 原因：一直压栈，没有弹栈，栈内存不够用。  

### 7.3.3 会画出递归方法的内存结构图。

- 递归的过程当中可以将图画出来。

### 7.3.4 能够使用循环代替递归的尽量使用循环

- 循环的执行耗费内存少一些，递归耗费内存相对多一些，另外递归使用不当很容易内存溢出，JVM停止工作。当然，只有极少数情况下，只能使用递归，而其它代码解决不了问题。

### 7.3.5 当递归有结束条件，并且结束条件合法的时候，就一定不会内存溢出吗？

- 也不一定。可能递归的太深了。

### 7.3.6 分享了一些递归方面的经验

- 在实际的开发中遇到递归导致的栈内存溢出错误是怎么办？
  - 第一步：先检查结束条件是否正确。
  -  第二步：如果正确，可以调整JVM的栈内存大小。(java -X)

# 8.认识面向对象

## 8.1 面向过程和面向对象有什么区别？

- 从语言方面出发

  - 对于C语言来说，是完全面向过程的。

  - 对于C++语言来说，是一半面向过程，一半是面向对象。（C++是半面向对象的）

  - 对于Java语言来说，是完全面向对象的。

- 什么是面向过程的开发方式？

  - 面向过程的开发方式主要的特点是：注重步骤，注重的是实现这个功能的步骤。

    - 第一步干什么
    - 第二步干什么
    - ....

  - 另外面向过程也注重实现功能的因果关系。

    - 因为A所有B

    - 因为B所以C

    - 因为C所以D

    - .....

  - 面向过程中没有对象的概念。只是实现这个功能的步骤以及因果关系。

- 面向过程有什么缺点？（耦合度高，扩展力差）

  - 面向过程最主要是每一步与每一步的因果关系，其中A步骤因果关系到B步骤，A和B联合起来形成一个子模块，子模块和子模块之间又因为因果关系结合在一起，假设其中任何一个因果关系出现问题（错误），此时整个系统的运转都会出现问题。（代码和代码之间的**耦合度太高，扩展力太差**。）

  - **例如：**

    - 螺栓螺母拧在一起是耦合度低的，因为螺栓螺母可以再拧开。（它们之间是有接口的。）

    - 螺栓螺母拧在一起之后，再用焊条焊接在一起，耦合度就很高了。耦合度就是黏连程度。

    - 耦合度高导致扩展力差。（集成显卡：计算机显卡不是独立的，是集成到主板上的）

    - 耦合度低导致扩展力强。（灯泡和灯口关系，螺栓螺母关系）

  - **采用面向过程的方式开发一台计算机会是怎样？**

    - 这台计算机将没有任何一个部件，所有的都是融合在一起的，这台计算机是一个实心儿的，没有部件的一体机。假设这台一体机的任何一个“部位”出问题，整个计算机就不能用了，

    - 必须扔掉了。（没有对象的概念。）

  - **采用面向对象的方式开发一台计算机会是怎样？**
    - 内存条是一个对象、主板是一个对象、CPU是一个对象、硬盘是一个对象、然后这些对象组装在一起，形成一台计算机。假设其中CPU坏了，我们可以将CPU拆下来，换一个新的。

- 面向过程有什么优点？（快速开发）
  - 对于小型项目（功能），采用面向过程的方式进行开发，效率较高。不需要前期进行对象的提取，模型的建立，采用面向过程方式可以直接开始干活。一上来直接写代码，编写因果关系。从而实现功能。

- 什么是面向对象的开发方式？
  - 采用面向对象的方式进行开发，更符合人类的思维方式，这也是面向对象成为主流的原因。人类就是以“对象”的方式去认识世界的，所以面向对象更容易让我们接受。面向对象就是将现实世界分割成不同的单元，然后每一个单元都实现成对象，然后给一个环境驱动一下，让各个对象之间协作起来形成一个系统。
    - 例如：对象“张三”、对象“香烟”、对象“打火机”、对象“吸烟的场所”，然后将这4个对象组合在一起，就可以模拟一个人的抽烟场景。其中“张三”对象可以更换为“李四”、其中“香烟”也可以更换品牌、其中“打火机”也可以更换、其中“吸烟的场所”也可以更换。

- 面向对象有什么优点？（耦合度低，扩展力强）

  - 例：面向对象和面向过程的区别
    - 蛋炒饭：鸡蛋和米饭完全混合在一起。没有独立对象的概念。假设客户提出新需求：我只想吃蛋炒饭中的米饭，怎么办？客户提出需求，软件开发者必须满足这个需求，于是开始扩展，这个软件的扩展是一场噩梦。（很难扩展，耦合度太高了。）
    - 鱼香肉丝盖饭：鱼香肉丝是一道菜，可以看成一个独立的对象。米饭可以看成一个独立的对象。两个对象准备好之后，只要有一个动作，叫做：“盖”。这样两个对象就组合在一起了。假设客户提出新需求：我不想吃鱼香肉丝盖饭,想吃西红柿鸡蛋盖饭。这个扩展就很轻松了。直接把“鱼香肉丝”对象换成“西红柿鸡蛋”对象。

  - 目前先听一下，需要三四年的时候才能彻底领悟面向对象。

  - 面向过程主要关注的是：实现步骤以及整个过程。

  - 面向对象主要关注的是：对象A，对象B，对象C，然后对象ABC组合，或者CBA组合.....

- 当我们采用面向对象的方式贯穿整个系统的话，涉及到三个术语：

  - OOA：面向对象分析
  - OOD：面向对象设计
  - OOP：面向对象编程
  - 整个软件开发的过程，都是采用OO进行贯穿的。实现一个软件的过程：分析(A) --> 设计(D) --> 编程(P)

- 面向对象包括三大特征

  - 封装、继承、多态。

  - 任何一个面向对象的编程语言都包括这三个特征，如：python也有封装 继承 多态，java也有封装 继承 多态。java只是面向对象编程语言中的一种，除了java之外，还有其它很多很多的编程语言也是面向对象的。以上三个特征的名字先背会，后面一个一个进行学习。

## 8.2 类和对象的概念

面向对象当中最主要“一词”是：对象。

- 什么是类？
  - 类实际上在现实世界当中是不存在的，是一个抽象的概念，是一个模板，是我们人类大脑进行“思考、总结、抽象”的一个结果。类本质上是现实世界当中某些事物具有共同特征，将这些共同特征提取出来形成的概念就是一个“类”，“类”就是一个模板。例如：明星就是一个类。

- 什么是对象？

  - 对象是实际存在的个体。例如：宋小宝就是一个对象、姚明就是一个对象、刘德华就是一个对象，宋小宝、姚明、刘德华这3个对象都属于“明星”这个类。

  - 在java语言中，要想得到“对象”，必须先定义“类”，“对象”是通过“类”这个模板创造出来的。类就是一个模板，类中描述的是所有对象的“共同特征信息”，对象就是通过类创建出的个体。

- 术语总结

  - 类：不存在的，人类大脑思考总结一个模板（这个模板当中描述了共同特征。）

  - 对象：实际存在的个体。

  - 实例：对象还有另一个名字叫做实例。

  - 实例化：通过类这个模板创建对象的过程，叫做实例化。

  - 抽象：多个对象具有共同特征，进行思考总结抽取共同特征的过程。

    ![image-20240531162542130](assets/image-20240531162542130.png)

    - 类是一个模板，是描述共同特征的一个模板，那么共同特征包括什么呢？

      - 例如：

        -  潘长江对象（姓名：潘长江、身高：165cm、打篮球：非专业球员能力很菜、学习：考试80分）；

        -  姚明对象（姓名：姚明、身高：240cm、打篮球：NBA专业球员能力非常棒、学习：考试100分）；

        - 这两个对象共同特征包括：

          -  名字、身高都属于名词（状态特征）；

          -  打篮球、学习都属于动词（动作特征）；

          -  类 = 属性 + 方法，属性来源于**状态**，方法来源于**动作**。

            ```
            public class 明星类{
                   //属性-->状态，多见于名词
                   名字属性;
                   身高属性;
            
                   //方法-->动作，多见于动词
                   打篮球方法(){
                   
                   }
                   学习方法(){
                  
            	   }
            }
            ```

            

- 思考：“java软件工程师”在开发中起到的一个作用是什么？
  - 软件开发既然是为了解决现实世界当中的问题，那么首先java软件必须能够模拟现实世界。其实软件是一个虚拟的世界，这个虚拟的世界需要和现实世界一一对应，这才叫模拟。java软件工程师起着用软件模拟现实世界的桥梁的作用。

## 8.3 类的定义

- 语法格式

  ```
  [修饰符列表] class 类名 {
          // 类体 = 属性 + 方法
          // 属性在代码上以“变量”的形式存在（描述状态）
          // 方法描述动作/行为
  }
  ```

  - 注意：修饰符列表可以省略。

- 为什么属性是“以”变量的形式存在的？

  - 假设我们要描述一个学生，学生包括以下属性：

    ```
    学号: 110
    姓名："张三"
    性别：'男' (true/false)
    住址："深圳宝安区"
    ```

  - 答案：是因为属性对应的是“数据”，数据在程序中只能放到变量中。

  - 结论：属性其实就是变量。

    - 变量根据出现位置进行划分：

      - 方法体当中声明的变量：局部变量。

      - 方法体外声明的变量：成员变量。（这里的成员变量就是“属性”）

# 9.对象的创建和使用

## 9.1 对象的创建

- 语法格式

  ```
  类名 变量名 = new 类名();
  ```

- 什么是实例变量

  - 对象又被称为实例。实例变量实际上就是对象级别的变量。

    ```
    public class 明星类{
    	double height;
    }
    ```

    - 身高这个属性所有的明星对象都有，但是每一个对象都有“自己的身高值”。假设创建10个明星对象，height变量应该有10份。所以这种变量被称为对象级别的变量，属于实例变量。
    - 实例变量在访问的时候，是不是必须先创建对象？是

- 对象和引用的区别

  - 对象：是通过new出来的，在堆内存中存储。
  - 引用：是存储对象内存地址的一个变量，可能存储在栈中，也可能存储在堆中。

- 关于编译的过程

  Student.java文件

  ```java
  public class Student{
  	String no;
  	String name;
  	boolean gender;
  	String addr;
  }
  ```

  StudentTest.java文件

  ```java
  public class StudentTest{
  	public static void main(String[] args){
  		Student s1 = new Student();
  	}
  }
  ```

  这两个文件是在同一目录下的，按说应该先编译Student.java，然后再编译StudentTest.java，但是对于编译器来说，编译StudentTest.java文件的时候，会自动找Student.class，如果没有，会自动编译Student.java文件，生成Student.class文件。

  - 第一种方式：   

    ```
    javac Student.java
    javac StudentTest.java
    ```

  - 第二种方式：

    ```
    javac StudentTest.java
    ```

  - 第三种方式：

    ```
    javac *.java
    ```

## 9.2 内存图

- 画内存图注意事项

  - 第一：在内存图上不要体现出代码。内存上应该主要体现“数据”。

  - 第二：画图的时候，图上的图形应该有先后顺序，先画什么，再画什么，必须是有顺序的，而不是想起来这个画这个，想起来那个画那个。程序代码是有执行顺序的，程序执行到哪里你就画哪里就行了。

- 画内存图的目的

  - 第一：有了内存图，程序不运行，我也知道结果。（可以推算出结果）

  - 第二：有了内存图，有助于你调试程序。画内存图是对Java运行机制的一种理解。不知道运行机制，以后复杂的程序出现错误之后你是不会调试的，调不明白。

- 例：画出以下Java程序的内存图。

  - Address.java

    ```
    public class Address{
    	String city; 
    	String street;
    	String zipcode;
    }
    ```

  - User.java

    ```
    public class User{
    	int id;
    	String username; 
    	Address addr; 
    }
    ```

  - Test.java

    ```
    public class Test{
    	public static void main(String[] args){
    		Address a = new Address();
    		a.city = "北京";
    		a.street = "大兴区";
    		a.zipcode = "121221";
    		
    		User u = new User();
    		System.out.println(u.id); // 0
    		System.out.println(u.username); // null
    		System.out.println(u.addr); // null
    
    		u.id = 11111;
    		u.username = "zhangsan";
    		u.addr = a;
    	}
    }
    ```

    画出的内存图如下所示：

    ![image-20240531171706486](assets/image-20240531171706486.png)

## 9.3 对象的使用

- 空指针异常

  - 空引用 访问 "对象相关"的数据时，会出现空指针异常。

  - 垃圾回收器主要针对堆内存。

- 方法在调用的时候参数是如何传递的？
  - 实际上，在java语言中，方法调用时参数传递，和类型无关，都是将变量中保存的那个“值”传过去，这个“值”可能是一个数字“100”，也可能是一个java对象的内存地址“0x1234”。
  - 记住这句话：不管是哪一种数据类型的传递，都是将“变量中保存的那个值复制一份传递过去。java中永远都是值传递。

## 9.4 构造方法

- 构造方法的作用
  - 创建对象，初始化实例变量（为实例变量赋初值）。

- 构造方法的定义

  ```
  [修饰符列表] 构造方法名(形式参数列表){
           构造方法体;
           通常在构造方法体当中给属性赋值，完成属性的初始化。
  }
  ```

  - 注意
    - 修饰符列表目前统一写public，千万不要写public static。
    - 构造方法名和类名必须一致。
    - 构造方法不需要指定返回值类型，也不能写void，写上void表示普通方法，就不是构造方法了。

- 构造方法的调用

  ```
  new 构造方法名(实际参数列表);
  ```

- 构造方法的一些要点

  - 当一个类中没有提供任何构造方法，系统默认提供一个无参数的构造方法。这个无参数的构造方法叫做缺省构造器。

  - 当一个类中手动的提供了构造方法，那么系统将不再默认提供无参数构造方法。建议将无参数构造方法手动的写出来，这样一定不会出问题。

  - 无参数构造方法和有参数的构造方法都可以调用。

    ```
    Student x = new Student();
    Student y = new Student(123);
    ```

  - 构造方法是支持方法重载的。在一个类当中构造方法可以有多个。并且所有的构造方法名字都是一样的。方法重载特点：在同一个类中，方法名相同，参数列表不同。

  - 对于实例变量来说，只要你在构造方法中没有手动给它赋值，统一都会默认赋值。默认赋系统值。

  - 实例变量不是在类加载时初始化，实例变量是在创建对象的时候初始化。

# 10.封装

面向对象的三大特征：封装、继承、多态。

有了封装，才有继承，有了继承，才能说多态。

## 10.1 什么是封装，有什么用？

- 现实生活中有很多现实的例子都是封装的，如手机，电视机，笔记本电脑，照相机，这些都是外部有一个坚硬的壳儿。封装起来，保护内部的部件，保证内部的部件是安全的。另外封装了之后，对于我们使用者来说，我们是看不见内部的复杂结构的，我们也不需要关心内部有多么复杂，我们只需要操作外部壳儿上的几个按钮就可以完成操作。


- 封装的作用：

  - 保证内部结构的安全。
  - 屏蔽复杂，暴露简单。

- 在代码级别上，封装有什么用？
  - 一个类体当中的数据，假设封装之后，对于代码的调用人员来说，不需要关心代码的复杂实现，只需要通过一个简单的入口就可以访问了。
  - 另外，类体中安全级别较高的数据封装起来，外部人员不能随意访问，来保证数据的安全性。

## 10.2 封装的代码实现

- 第一步：属性私有化

  - 使用private关键字进行修饰。

- 第二步：1个属性对外提供两个set和get方法。

  - 外部程序只能通过set方法修改，只能通过get方法读取，可以在set方法中设立关卡来保证数据的安全性。

  - 再强调一下：set和get方法都是实例方法，不能带static。

  - 不带static的方法称为实例方法，实例方法的调用必须先new对象。

  - set和get方法写的时候有严格的规范要求：

    - set方法长这个样子：

      ```
      public void set+属性名首字母大写(1个参数){
      	xxx = 1个参数;
      }
      ```

    - get方法长这个样子：

      ```
      public 返回值类型 get+属性名首字母大写(无参){
      	return xxx;
      }
      ```

      ​            

# 11.static和this

## 11.1 static关键字

- 变量的分类（根据声明的位置进行划分）：

  - 在方法体当中声明的变量叫做：局部变量。

  - 在方法体外声明的变量叫做：成员变量。
    - 成员变量又可以分为：实例变量和静态变量。

  - 一个对象一份的是实例变量，所有对象一份的是静态变量。

- static修饰的如何访问：

  - static修饰的统一都是静态的，都是类相关的，不需要new对象。直接采用“类名.”访问。但使用“引用.”访问也行（不建议使用"引用."），并且使用“引用.”访问静态的不会产生空指针异常。

  - 只有在“空引用”访问“实例”相关的，都会出现空指针异常。

- 成员变量什么时候定义成实例变量，什么时候定义成静态变量：
  - 当一个属性是类级别的属性，所有对象的这个属性的值是一样的，建议定义为静态变量。

- 成员方法什么时候定义成实例方法，什么时候定义成静态方法：

  - 当这个方法体当中，直接访问了实例变量，这个方法必须定义成实例方法。

  - 以后开发中，大部分情况下，如果是工具类的话，工具类当中的方法一般都是静态的。(静态方法有一个优点，是不需要new对象，直接采用类名调用，极其方便。工具类就是为了方便编程的，所以工具类中的方法一般都是static的。)

- 使用static关键字可以定义：静态代码块

  - 语法格式：

    ```
    static {
        java语句;
        java语句;
    }
    ```

  - static静态代码块在什么时候执行呢？

    - 类加载时执行，并且只执行一次，并且在main方法执行之前执行。

    - 静态代码块一般是按照自上而下的顺序执行。

    - 实例代码块在构造方法执行时执行。

  - 静态代码块的作用

    - 第一：静态代码块不是那么常用。（不是每一个类当中都要写的东西。）

    - 第二：静态代码块这种语法机制实际上是SUN公司给我们java程序员的一个特殊的时刻/时机。这个时机叫做：类加载时机。

      - 具体的业务：项目经理说了，大家注意了，所有我们编写的程序中，只要是类加载了，请记录一下

      - 类加载的日志信息（在哪年哪月哪日几时几分几秒，哪个类加载到JVM当中了）。这些记录日志的代码写到静态代码块当中。

  - 到目前为止，遇到的所有java程序，有顺序要求的是哪些？

    - 第一：对于一个方法来说，方法体中的代码是有顺序的，遵循自上而下的顺序执行。

    - 第二：静态代码块1和静态代码块2是有先后顺序的。

    - 第三：静态代码块和静态变量是有先后顺序的。

- 实例代码块

  - 除了静态代码块之外，还有一种语句块叫做实例语句块，实例语句在类加载时并没有执行。

  - 语法格式：

    ```
    {
         java语句;
         java语句;
         java语句;
    }
    ```

  - 实例语句块在什么时候执行？
    - 只要是构造方法执行，必然在构造方法执行之前，自动执行“实例语句块”中的代码。实际上这也是SUN公司为java程序员准备一个特殊的时机，叫做对象构建时机。

## 11.2 this关键字

- this是一个关键字，是一个引用。this保存当前对象的内存地址，指向自身。所以，严格意义上来说，this代表的就是“当前对象”，this存储在堆内存当中对象的内部。
- this可以使用在实例方法中，也可以使用在构造方法中。
- this出现在实例方法中其实代表的是当前对象。
- this不能使用在静态方法中。 因为静态方法使用“**类名.**”的方式调用，它不存在当前对象，this也就不存在。
- this. 大部分情况下可以省略，但是用来区分局部变量和实例变量的时候不能省略。
- this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用。

# 12.继承

## 12.1 什么是继承，有什么作用？

- 继承：在现实世界当中也是存在的，例如：父亲很有钱，儿子不用努力也很有钱。

- 继承的作用：
  - 基本作用：子类继承父类，代码可以得到复用。
  - 主要作用：因为有了继承关系，才有了后期的方法覆盖和多态机制。

## 12.2 继承的相关特性

- B类继承A类，则称A类为超类(superclass)、父类、基类，B类则称为子类(subclass)、派生类、扩展类。
- java 中的继承只支持单继承，不支持多继承，C++中支持多继承，这也是 java 体现简单性的一点，换句话说，java 中不允许这样写代码。
  - 例如：class B extends A,C{ } 这是错误的。
  - 虽然 java 中不支持多继承，但有的时候会产生间接继承的效果，
    - 例如：class C extends B，class B extends A，也就是说，C 直接继承 B，其实 C 还间接继承 A。
- java 中规定，子类继承父类，除构造方法不能继承之外，剩下都可以继承。但是私有的属性无法在子类中直接访问。(父类中private修饰的不能在子类中直接访问。可以通过间接的手段来访问。)
- java 中的类没有显示的继承任何类，则默认继承 Object类，Object类是 java 语言提供的根类（老祖宗类），也就是说，一个对象与生俱来就有 Object类型中所有的特征。
- 继承也存在一些缺点，例如：CreditAccount 类继承 Account 类会导致它们之间的耦合度非常高，Account 类发生改变之后会马上影响到 CreditAccount 类。

- 子类继承父类之后，能使用子类对象调用父类方法吗？
  - 可以，因为子类继承了父类之后，这个方法就属于子类了。当然可以使用子类对象来调用。

- 在实际开发中，满足什么条件的时候，我可以使用继承呢？

  - 凡是采用“is a”能描述的，都可以继承。例如：

    ```
    Cat is a Animal：猫是一个动物
    Dog is a Animal：狗是一个动物
    CreditAccount is a Account：信用卡账户是一个银行账户
    ....
    ```

  - 假设以后的开发中有一个A类，有一个B类，A类和B类确实也有重复的代码，那么他们两个之间就可以继承吗？不一定，还是要看一看它们之间是否能够使用is a来描述。

    ```
    class Customer{
        String name; // 名字
        // setter and getter
    }
    class Product{
        String name; // 名字
        // setter and getter
    }
    class Product extends Customer{
    
    }
    以上的继承就属于很失败的。因为：Product is a Customer，是有违伦理的。
    ```

## 12.3 任何一个类，没有显示继承任何类，默认继承Object，那么Object类当中有哪些方法呢？

- 以后慢慢的大家一定要适应看JDK的源代码（多看看牛人写的程序自己才会变成牛人。）先模仿后超越。

- java为什么比较好学呢？是因为Java内置了一套庞大的类库，程序员不需要从0开始写代码，程序员可以基于这套庞大的类库进行“二次”开发。（开发速度较快，因为JDK内置的这套库实现了很多基础的功能。）例如：String是SUN编写的字符串类、System是SUN编写的系统类。这些类都可以拿来直接使用。

-  JDK源代码在什么位置？

  ```
  C:\Program Files\Java\jdk-13.0.2\lib\src.zip
  ```

- 现在能看懂以下代码了吗？

  ```
  System.out.println("Hello World!");
  ```

  - System.out 中，out后面没有小括号，说明out是变量名。另外System是一个类名，直接使用类名System.out，说明out是一个静态变量。
  - System.out 返回一个对象，然后采用“对象.”的方式访问println()方法。

  - 我们研究了一下Object类当中有很多方法，大部分看不懂，其中有一个叫做toString()的，我们进行了测试，发现：System.out.println(引用);
    - 当直接输出一个“引用”的时候，println()方法会先自动调用“引用.toString()”，然后输出toString()方法的执行结果。

# 13.方法覆盖和多态

## 13.1 方法覆盖 

- 什么时候考虑使用方法覆盖？
  - 父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。

- 什么条件满足的时候构成方法覆盖？

  - 第一：有继承关系的两个类

  - 第二：具有相同方法名、返回值类型、形式参数列表

  - 第三：访问权限不能更低。

  - 第四：抛出异常不能更多。

- 关于Object类中toString()方法的覆盖？

  - toString()方法存在的作用就是将java对象转换成字符串形式。在大多数的java类中对于继承自Object类的toString()方法都是需要覆盖的。因为Object类中提供的toString()方法输出的是一个java对象的内存地址。

  - 至于toString()方法具体怎么进行覆盖其格式可以自己定义，或者听需求的。（听项目要求的。）

- 方法重载和方法覆盖有什么区别？

  - 方法重载发生在同一个类当中。方法覆盖是发生在具有继承关系的父子类之间。

  - 方法重载是一个类中，方法名相同，参数列表不同。方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致（方法名一致、参数列表一致、返回值类型一致）。

## 13.2 多态

- 向上转型和向下转型的概念

  - 向上转型：子→父 (upcasting)

    - 又被称为自动类型转换：Animal a = new Cat();

  - 向下转型：父→子 (downcasting)

    - 又被称为强制类型转换：Cat c = (Cat)a; 需要添加强制类型转换符。

    - 什么时候需要向下转型？
      - 需要调用或者执行子类对象中特有的方法。必须进行向下转型，才可以调用。
    - 向下转型有风险吗？
      -  容易出现ClassCastException（类型转换异常）

    - 怎么避免这个风险？
      - instanceof运算符，可以在程序运行阶段动态的判断某个引用指向的对象是否为某一种类型。
      - 养成好习惯，向下转型之前一定要使用instanceof运算符进行判断。
      - 不管是向上转型还是向下转型，首先他们之间必须有继承关系，这样编译器就不会报错。

- 什么是多态

  - 多种形态，多种状态，编译和运行有两个不同的状态。

    - 编译期叫做静态绑定，运行期叫做动态绑定。  

      ```
      Animal a = new Cat();
      // 编译的时候编译器发现a的类型是Animal，所以编译器会去Animal类中找move()方法
      // 找到了，绑定，编译通过。但是运行的时候和底层堆内存当中的实际对象有关
      // 因为new对象发生在运行阶段。
      // 真正执行的时候会自动调用“堆内存中真实对象”的相关方法。
      a.move();
      ```

    - 多态的典型代码：父类型的引用指向子类型的对象。（java中允许这样写代码！！！）

  - 多态在开发中有什么作用（非常重要）？

    - 降低程序的耦合度，提高程序的扩展力。

      ```java
      public class Master{
          public void feed(Dog d){
          	d.eat();
          }
          public void feed(Cat c){
          	c.eat();
          }
      }
      ```

    - 以上的代码中表示：Master和Dog以及Cat的关系很紧密（耦合度高）。导致扩展力很差。

      ```java
      public class Master{
          public void feed(Pet pet){
          	pet.eat();
          }
      }
      ```

    -  以上的代码中表示：Master和Dog以及Cat的关系就脱离了，Master关注的是Pet类。这样Master和Dog以及Cat的耦合度就降低了，提高了软件的扩展性。

  -  面向对象的三大特征为封装、继承、多态，真的是一环扣一环。有了封装，有了这种整体的概念之后。对象和对象之间产生了继承。有了继承之后，才有了方法的覆盖和多态。

  -  软件开发七大原则最基本的原则：OCP（对扩展开放，对修改关闭）
    -  目的是：降低程序耦合度，提高程序扩展力。面向抽象编程，不建议面向具体编程。

  - 解释之前遗留的问题

    - 私有方法无法覆盖。
    - 方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。（这是因为方法覆盖通常和多态联合起来）
    - 总结两句话：私有不能覆盖，静态不谈覆盖。

    - 在方法覆盖中，关于方法的返回值类型：

      -  方法覆盖需要满足的条件：

        - 发生具有继承关系的两个类之间。

        - 父类中的方法和子类重写之后的方法：具有相同的方法名、相同的形式参数列表、相同的返回值类型。

          -  学习了多态机制之后：“相同的返回值类型”可以修改一下吗？

          -  对于返回值类型是基本数据类型来说，必须一致。

          -  对于返回值类型是引用数据类型来说，重写之后返回值类型可以变的更小（但意义不大，实际开发中没人这样写。）。

## 13.3 super关键字

- super关键字代表的就是“当前对象”的那部分父类型特征。

- super能出现在实例方法和构造方法中。

- super的语法是：“super.”、“super()”

- super不能使用在静态方法中。

- super. 大部分情况下是可以省略的。

  - super.什么时候不能省略呢？
    - 从父类继承过来的那部分特征当中的某些属性和子类中的某些属性同名，或者说有同样的方法，想在子类中访问父类型特征中的哪些属性或方法，super. 不能省略。

  - super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中的构造方法，目的是：创建子类对象的时候，先初始化该对象的父类型特征。

- super的使用：
  - super.属性名：访问父类型特征中的属性；
  - super.方法名(实参)：访问父类型特征中的方法；
  - super(实参)：调用父类的构造方法来初始化父类型特征中的属性。

- 用一个程序及其内存图深入理解super

  ```java
  public class SuperTest03{
  	public static void main(String[] args){
  		CreditAccount ca1 = new CreditAccount();
  		System.out.println(ca1.getActno() + "," + ca1.getBalance() + "," + ca1.getCredit());
  		CreditAccount ca2 = new CreditAccount("1111", 10000.0, 0.999);
  		System.out.println(ca2.getActno() + "," + ca2.getBalance() + "," + ca2.getCredit());
  	}
  }
  // 账户
  class Account extends Object{
  	// 属性
  	private String actno;
  	private double balance;
  	// 构造方法
  	public Account(){
  	}
  	public Account(String actno, double balance){
  		this.actno = actno;
  		this.balance = balance;
  	}
  	// setter and getter
  	public void setActno(String actno){
  		this.actno = actno;
  	}
  	public String getActno(){
  		return actno;
  	}
  	public void setBalance(double balance){
  		this.balance = balance;
  	}
  	public double getBalance(){
  		return balance;
  	}
  }
  // 信用账户
  class CreditAccount extends Account{
  	// 属性：信誉度（诚信值）
  	// 子类特有的一个特征，父类没有。
  	private double credit;
  	// 构造方法
  	public CreditAccount(String actno, double balance, double credit){
  		// 以上两行代码在恰当的位置，正好可以使用：super(actno, balance);
  		// 通过子类的构造方法调用父类的构造方法。
  		super(actno, balance);
  		this.credit = credit;
  	}
  	// 提供有参数的构造方法
  	public CreditAccount(){
  	}
  	// setter and getter方法
  	public void setCredit(double credit){
  		this.credit = credit;
  	}
  	public double getCredit(){
  		return credit;
  	}
  }
  ```

  ![image-20240601211219684](assets/image-20240601211219684.png)

## 13.4 super和this对比着学习

- this

  - this能出现在实例方法和构造方法中。

  - this的语法是：“this.”、“this()”

  - this不能使用在静态方法中。

  - this. 大部分情况下是可以省略的。

  - this.什么时候不能省略呢？ 在区分局部变量和实例变量的时候不能省略。

    ```
     public void setName(String name){
         this.name = name;
     }
    ```

  -  this() 只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中其它的构造方法，目的是：代码复用。

- super

  - super能出现在实例方法和构造方法中。

  -  super的语法是：“super.”、“super()”

  -  super不能使用在静态方法中。

  -  super. 大部分情况下是可以省略的。

  -  super.什么时候不能省略呢？
    - 从父类继承过来的那部分特征当中的某些属性和子类中的某些属性同名，或者说有同样的方法，想在子类中访问父类型特征中的哪些属性或方法，super. 不能省略。

  -  super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。

# 14.IDEA继承开发环境的使用

## 14.1 关于java的集成开发环境

- 常用的有eclipse、IntelliJ IDEA等，其中目前主流的集成开发环境是：IntelliJ IDEA
- 开发工具不要使用汉化版，太low。
- 英语单词太多别害怕，记位置。（一共就那几个主要的操作位置。）

## 14.2 IDEA工具的使用

- 第一步：第一次打开的时候：会弹出一个窗口（import idea settings）这个表示导入idea的设置，但我们是第一次使用idea工具，没有设置过idea，所以这里选择：do not import setting...不导入设置。
- 第二步：会让你接受条款，接受即可。
- 第三步：don't send
- 第四步：一直下一步（最终选择免费试用30天。）
- 第五步：可能会让你填写email等信息，这里不填写，继续continue。
- 第六步：弹出welcome窗口，点击create new project
  - 注意：在IDEA当中一个project相当于eclipse当中的一个workspace。
- 第七步：新建一个Empty Project，即新建一个空的工程，选择创建工程窗口下面“最后的那一项”，Empty Project
- 第八步：给空的工程起一个名字叫javase，存储到：C:\Users\Administrator\IdeaProjects\javase，点击finish。
- 第九步：自动弹出一个每日提示，这个每日提示可以取消掉。以后每一次打开就不再提示了。
- 第十步：会自动弹出一个project structure，这个窗口先取消掉。
- 第十一步：在空的工程下新建Module（模块），IDEA中模块类似于eclipse当中的project。
  - eclipse的组织方式：workspace--> project
  - idea的组织方式：project --> module
  - 怎么创建module?file菜单-->new --> Module
- 第十二步：在New Module窗口上点击左上角的java，然后next
- 第十三步：给module起一个名字：chapter15
- 第十四步：编写代码，在src目录下新建类，写代码，并运行。

## 14.3 关于IDEA工具的快捷键以及一些简单的设置

- 字体设置
  - file → settings → 输入font → 设置字体样式以及字号大小。

- 快速生成main方法：psvm

- 快速生成System.out.println()：sout 
  - 注意：IDEA是自动保存，不需要ctrl + s

- 删除一行：ctrl + y

- 运行程序
  - 方式1：代码上鼠标右键 → run
  - 方式2：点击左侧的绿色箭头。
  - 方式3：ctrl + shift + F10

- 左侧窗口中的列表怎么展开？怎么关闭？
  - 左箭头关闭，右箭头展开，上下箭头移动。

- idea中退出任何窗口：使用esc键

- 任何新增/新建/添加的快捷键是：alt + insert

- 窗口变大，变小：ctrl + shift + F12

- 切换java程序：从HelloWorld.java切换到User.java："alt + 右箭头" 或者 alt + "左箭头"

- 关闭某个java程序：ctrl + F4

- 切换窗口
  - alt + 标号
    - alt + 1（打开，关闭）
    - alt + 2

- 提示方法的参数：ctrl + p

- 注释
  - 单行注释：ctrl + /
  - 多行注释：ctrl + shift + /  

- idea中怎么定位方法/属性/变量？
  - 光标停到某个单词的下面，这个单词可能是方法名、变量名，停到单词下面之后，按ctrl键，出现下划线，点击跳转。

- idea当中复制一行：ctrl + d

# 15.面向对象进阶（养成写代码能用多态尽量用多态的习惯）

## 15.1 final关键字

- final修饰的类无法继承。

- final修饰的方法无法覆盖。

- final修饰的变量只能赋一次值。

- final修饰的引用一旦指向某个对象，则不能再重新指向其它对象，但该引用指向的对象内部的数据是可以修改的。

- final修饰的实例变量必须手动初始化，不能采用系统默认值。

- final修饰的实例变量一般和static联合使用，称为常量。

  ```
  public static final double PI = 3.1415926;
  ```

## 15.2 抽象类和接口

### 15.2.1 抽象类

- 抽象类的基础语法

  - 抽象类怎么定义？在class前添加abstract关键字就行了。

  - 抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。

  - final和abstract不能联合使用，这两个关键字是对立的。

  - 抽象类的子类可以是抽象类。也可以是非抽象类。

  - 抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。

  - 抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。

    - 抽象方法怎么定义？

      ```
      public abstract void doSome();
      ```

  - ☆☆☆☆☆ 一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖/重写/实现。

- 到目前为止，只是学习了抽象类的基础语法，一个类到底声明为抽象还是非抽象，这个以后慢慢来吧。写代码多的时候，自然就理解了。

- 面试题（判断题）

  - java语言中凡是没有方法体的方法都是抽象方法。

    - 答案：×

    - 解析：Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们都不是抽象方法，例如：public native int hashCode(); 这个方法底层调用了C++写的动态链接库程序。前面修饰符列表中没有abstract，有一个native，表示调用JVM本地程序。

### 15.2.2 接口

- 接口的基础语法

  - 接口是一种“引用数据类型”。

  - 接口是完全抽象的。

  - 接口怎么定义：

    ```
    [修饰符列表] interface 接口名{}
    ```

  - 接口支持多继承（一个接口可继承多个接口）。

  - 接口中只有常量+抽象方法。

    - 接口中所有的元素都是public修饰的
    - 接口中抽象方法的public abstract可以省略。
    - 接口中常量的public static final可以省略。
    - 接口中方法不能有方法体。

  - 一个非抽象的类，实现接口的时候，必须将接口中所有方法加以实现。

  - 一个类可以实现多个接口。

  - extends和implements可以共存，extends在前，implements在后。

  - 使用接口，写代码的时候，可以使用多态（父类型引用指向子类型对象）。

- 接口在开发中的作用

  - 注意：接口在开发中的作用，类似于多态在开发中的作用。

  - 多态：面向抽象编程，不要面向具体编程。降低程序的耦合度。提高程序的扩展力。

    ```
    /*
    public class Master{
        public void feed(Dog d){}
        public void feed(Cat c){}
    	//假设又要养其它的宠物，那么这个时候需要再加1个方法。（需要修改代码了）
    	//这样扩展力太差了，违背了OCP原则（对扩展开放，对修改关闭。）
    }
    */
    
    public class Master{
        public void feed(Animal a){
        	// 面向Animal父类编程，父类是比子类更抽象的。
        	//所以我们叫做面向抽象编程，不要面向具体编程。
        	//这样程序的扩展力就强。
    	}
    }
    ```

  - 面向抽象编程这句话以后可以修改为面向接口编程，有了接口就有了可插拔，可插拔表示扩展力很强，不是焊接死的。

    - 主板和内存条之间有插槽，这个插槽就是接口，内存条坏了，可以重新买一个换下来。这叫做高扩展性。（低耦合度。）

  - 接口的作用总结一句话：三个字“解耦合”

    - 面向接口编程，可以降低程序的耦合度，提高程序的扩展力。符合OCP开发原则。
    - 接口的使用离不开多态机制。（接口+多态才可以达到降低耦合度。）

    - 接口可以解耦合，解开的是谁和谁的耦合：
      - 任何一个接口都有调用者和实现者。接口可以将调用者和实现者解耦合。调用者面向接口调用。实现者面向接口编写实现。以后进行大项目的开发，一般都是将项目分离成一个模块一个模块的，模块和模块之间采用接口衔接。降低耦合度。

### 15.2.3 类型和类型之间的关系

- is a（继承）

  - Cat is a Animal（猫是一个动物）。凡是能够满足is a的表示“继承关系”

    ```
    A extends B
    ```

- has a（关联）

  - I has a Pen（我有一支笔），凡是能够满足has a关系的表示“关联关系”，关联关系通常以“属性”的形式存在。

    ```
    A{
    	B b;
    }    
    ```

- like a（实现）

  - Cooker like a FoodMenu（厨师像一个菜单一样），凡是能够满足like a关系的表示“实现关系”，实现关系通常是：类实现接口。

    ```
    A implements B
    ```

### 15.2.4 抽象类和接口的区别

在这里我们只说一下抽象类和接口在语法上的区别。至于以后抽象类和接口应该怎么进行选择，通过后面的项目去体会/学习。

- 抽象类是半抽象的，接口是完全抽象的。
- 抽象类中有构造方法，接口中没有构造方法。

- 接口和接口之间支持多继承，类和类之间只能单继承。

- 一个类可以同时实现多个接口， 一个类只能继承一个抽象类（单继承）。

- 接口中只允许出现常量和抽象方法。

这里先透露一个信息：以后接口使用的比抽象类多。一般抽象类使用的还是少。接口一般都是对“行为”的抽象。

## 15.3 package和import（不用测，知道就行）

### 15.3.1 package

- package的基础语法

  - 第一：package出现在java源文件第一行。

  - 第二：带有包名怎么编译？javac -d . xxx.java

  - 第三：怎么运行？java 完整类名

- 补充：以后说类名的时候，如果带着包名描述，表示完整类名。如果没有带包，描述的话，表示简类名。

  ```
  java.util.Scanner 完整类名。
  Scanner 简类名
  ```

### 15.3.2 import

- import什么时候不需要？

  - java.lang不需要，同包下不需要。，其它一律都需要。

- 语法格式：

  ```
  import 完整类名;
  import 包名.*;
  ```

  ```
  import java.util.Scanner; // 完整类名。
  
  // 同学的疑问：这样是不是效率比较低。
  // 这个效率不低，因为编译器在编译的时候，会自动把*变成具体的类名。
  import java.util.*;
  
  // 想省懒劲你不能太省了。
  import java.*; 这是不允许的，因为在java语言中规定，这里的*只代表某些类的名字。
  ```

## 15.4 访问权限控制

### 15.4.1 访问控制权限都有哪四个

```
private		私有
public		公开
protected	受保护
默认
```

### 15.4.2 以上的4个访问控制权限：控制的范围是什么？

- private 表示私有的，只能在本类中访问
- public 表示公开的，在任何位置都可以访问
- “默认”表示只能在本类，以及同包下访问。
- protected表示只能在本类、同包、子类中访问。

| **访问控制修饰符** | **本类** | **同包** | **子类** | **任意位置** |
| ------------------ | -------- | -------- | -------- | ------------ |
| public             | **可以** | **可以** | **可以** | **可以**     |
| protected          | **可以** | **可以** | **可以** | 不行         |
| 默认               | **可以** | **可以** | 不行     | 不行         |
| private            | **可以** | 不行     | 不行     | 不行         |

这个不要死记硬背，自己下去之后编写代码自己测试。

范围从大到小排序：public > protected > 默认 > private

### 15.4.3 访问控制权限修饰符可以修饰什么？

```
属性（4个都能用）
方法（4个都能用）
类（public和默认能用，其它不行。）
接口（public和默认能用，其它不行。）
```

## 15.5 JDK类库的根类：Object

这个老祖宗类中的方法我们需要先研究一下，因为这些方法都是所有子类通用的。任何一个类默认继承Object。就算没有直接继承，最终也会间接继承。

### 15.5.1 Object类当中常用的方法

- 我们去哪里找这些方法呢？

  - 第一种方法：去源代码当中。（但是这种方式比较麻烦，源代码也比较难）

  - 第二种方法：去查阅java的类库的帮助文档。

- 什么是API？

  - 应用程序编程接口。（Application Program Interface）

  - 整个JDK的类库就是一个javase的API。

  - 每一个API都会配置一套API帮助文档。

  - SUN公司提前写好的这套类库就是API。（一般每一份API都对应一份API帮助文档。）

- 目前为止我们只需要知道这几个方法即可：

  ```java
  protected Object clone()  // 负责对象克隆的。
  int hashCode()   // 获取对象哈希值的一个方法。
  boolean equals(Object obj)  // 判断两个对象是否相等
  String toString()  // 将对象转换成字符串形式
  protected void finalize()  // 垃圾回收器负责调用的方法
  ```

-  Object类当中常用的方法

  - toString()方法

    - 以后所有类的toString()方法是需要重写的。
      - 重写规则：越简单越明了就好。

    - System.out.println(引用); 这里会自动调用“引用”的toString()方法。

    - String类是SUN写的，toString方法已经重写了。

  - equals()方法

    - 以后所有类的equals方法也需要重写，因为Object中的equals方法比较的是两个对象的内存地址，我们应该比较内容，所以需要重写。
      - 重写规则：自己定，主要看是什么和什么相等时表示两个对象相等。
    - 基本数据类型比较：用==
    - 对象和对象比较：调用equals方法

    - String类是SUN编写的，所以String类的equals方法重写了。

    - 以后判断两个字符串是否相等，最好不要使用==，要调用字符串对象的equals方法。
    - 注意：重写equals方法的时候要彻底。

  - finalize()方法

    - 这个方法是protected修饰的，在Object类中这个方法的源代码是？

      ```
      protected void finalize() throws Throwable { }
      ```

## 15.6 匿名内部类

### 15.6.1 什么是内部类？

- 在类的内部又定义了一个新的类，被称为内部类。

### 15.6.2 内部类的分类：

- 静态内部类：类似于静态变量
- 实例内部类：类似于实例变量
- 局部内部类：类似于局部变量

### 15.6.3 一些注意事项

- 使用内部类编写的代码，可读性很差。能不用尽量不用。

- 匿名内部类是局部内部类的一种。因为这个类没有名字而得名，叫做匿名内部类。

- 学习匿名内部类主要是让大家以后在阅读别人代码的时候，能够理解。并不代表以后都要这样写。因为匿名内部类有两个缺点：

  - 缺点1：太复杂，太乱，可读性差。
  - 缺点2：类没有名字，以后想重复使用，不能用。

- 不理解算了，你只要记住这种写法就行。

  ```java
  class Test01{
  	// 静态变量
  	static String country;
  	// 该类在类的内部，所以称为内部类
  	// 由于前面有static，所以称为“静态内部类”
  	static class Inner1{
  	}
  	
  	// 实例变量
  	int age;
  	// 该类在类的内部，所以称为内部类
  	// 没有static叫做实例内部类。
  	class Inner2{
  	}
  
  	// 方法
  	public void doSome(){
  		// 局部变量
  		int i = 100;
  		// 该类在类的内部，所以称为内部类
  		// 局部内部类。
  		class Inner3{
  		}
  	}
  
  	public void doOther(){
  		// doSome()方法中的局部内部类Inner3，在doOther()中不能用。
  	}
  
  	// main方法，入口
  	public static void main(String[] args){
  		// 调用MyMath中的mySum方法。
  		MyMath mm = new MyMath();
  		/*
  		Compute c = new ComputeImpl();
  		mm.mySum(c, 100, 200);
  		*/
  		
  		//合并（这样写代码，表示这个类名是有的。类名是：ComputeImpl）
  		//mm.mySum(new ComputeImpl(), 100, 200);
  	
  		// 使用匿名内部类，表示这个ComputeImpl这个类没名字了。
  		// 这里表面看上去好像是接口可以直接new了，实际上并不是接口可以new了。
  		// 后面的{} 代表了对接口的实现。
  		// 不建议使用匿名内部类，为什么？
  		// 因为一个类没有名字，没有办法重复使用。另外代码太乱，可读性太差。
  		mm.mySum(new Compute(){
  			public int sum(int a, int b){
  				return a + b;
  			}
  		}, 200, 300);
  
  	}
  
  }
  
  // 负责计算的接口
  interface Compute{ 
  	
  	// 抽象方法
  	int sum(int a, int b);
  }
  
  // 你自动会在这里编写一个Compute接口的实现类
  /*
  class ComputeImpl implements Compute{
  
  	// 对方法的实现
  	public int sum(int a, int b){
  		return a + b;
  	}
  }
  */
  
  // 数学类
  class MyMath{
  	// 数学求和方法
  	public void mySum(Compute c, int x, int y){
  		int retValue = c.sum(x, y);
  		System.out.println(x + "+" + y + "=" + retValue);
  	}	
  }
  
  ```

  

# 16.数组

## 16.1 数组的基础语法

### 16.1.1 数组的优点和缺点（要理解为什么）

- 第一：空间存储上内存地址是连续的，每个元素占用的空间大小相同。
- 第二：知道首元素的内存地址，通过下标可以计算出偏移量。通过一个数学表达式，就可以快速计算出某个下标位置上元素的内存地址，直接通过内存地址定位，效率非常高。

- 优点：检索效率高。
- 缺点：随机增删效率较低，数组无法存储大数据量。
- 注意：数组最后一个元素的增删效率不受影响。

### 16.1.2 一维数组的初始化和遍历

- 静态初始化

  ```java
  int[] arr = {1,2,3,4};
  Object[] objs = {new Object(), new Object(), new Object()};
  ```

- 动态初始化

  ```
  int[] arr = new int[4]; // 4个长度，每个元素默认值0
  Object[] objs = new Object[4]; // 4个长度，每个元素默认值null
  ```

- 一维数组的遍历

  ```
  for(int i = 0; i < arr.length; i++){
      System.out.println(arr[i]);
  }
  注意：length是属性不是方法，length为当前数组的总长度。
  ```

### 16.1.3 二维数组的初始化和遍历

- 静态初始化

  ```
  int[][] arr = {
      {1,2,34},
      {54,4,34,3},
      {2,34,4,5}
  };
  
  Object[][] arr = {
      {new Object(),new Object()},
      {new Object(),new Object()},
      {new Object(),new Object(),new Object()}
  };
  ```

- 动态初始化

  ```
  int[][] arr = new int[3][4];
  Object[][] arr = new Object[4][4];
  Animal[][] arr = new Animal[3][4];
  // Person类型数组，里面可以存储Person类型对象，以及Person类型的子类型都可以。
  Person[][] arr = new Person[2][2];
  ....
  ```

- 二维数组的遍历

  ```
  for(int i = 0; i < arr.length; i++){ // 外层for循环负责遍历外面的一维数组。
      // 里面这个for循环负责遍历二维数组里面的一维数组。
      for(int j = 0; j < arr[i].length; j++){
          System.out.print(arr[i][j]);
      }
      // 换行。
      System.out.println();
  }
  ```

### 16.1.4 main方法上“String[] args”参数的使用

- 非重点，了解一下，以后一般都是有界面的，用户可以在界面上输入用户名和密码等参数信息。

### 16.1.5 数组的拷贝：System.arraycopy()方法的使用

```
arraycopy(Object src,  int srcPos, Object dest, int destPos, int length);
    srcs：原数组；
    srcPos：从原数组哪个下标开始；
    dest：目标数组；
    destPos：从目标数组哪个下标开始；
    length：从原数组拷贝几个元素到目标数组；
数组有一个特点：长度一旦确定，不可变。
所以数组长度不够的时候，需要扩容，扩容的机制是：新建一个大数组，将小数组中的数据拷贝到大数组，然后小数组对象被垃圾回收。
```

- 注意：对数组中存储引用数据类型的情况，要会画它的内存结构图。

### 16.1.6 数组的排序：Arrays.sort()方法

底层是快速排序。

# 17.常用类

## 17.1 String类

### 17.1.1 对String在内存存储方面的理解

- 第一：字符串一旦创建不可变。
- 第二：双引号括起来的字符串存储在字符串常量池中。
- 第三：字符串的比较必须使用equals方法。
- 第四：String已经重写了toString()和equals()方法。

### 17.1.2 String的构造方法

```
String s = "abc";
String s = new String("abc");
String s = new String(byte数组);
String s = new String(byte数组, 起始下标, 长度);
String s = new String(char数组);
String s = new String(char数组, 起始下标, 长度);
```

### 17.1.3 String类常用的21个方法

- 实例方法

  ```
  char charAt(int index)
  获取字符串中某个下标位置的字符。
  
  int compareTo(String anotherString)
  比较两个字符串的大小。
  
  boolean contains(CharSequence s)
  判断当前字符串中是否包含某个子字符串s。
  
  boolean endsWith(String suffix)
  判断当前字符串是否以某个子字符串结尾。
  
  boolean equals(Object anObject)
  判断两个字符串是否相等。
  
  boolean equalsIgnoreCase(String anotherString)
  判断两个字符串是否相等，并且同时忽略大小写。
  
  byte[] getBytes()
  将字符串对象转换成字节数组。
  
  int indexOf(String str)
  判断某个子字符串在当前字符串中第一次出现处的索引（下标）
  
  boolean isEmpty()
  判断某个字符串是否为“空字符串”
  
  int length()
  面试题：判断数组长度和判断字符串长度不一样
  判断数组长度是length属性，判断字符串长度是length()方法。
  
  int lastIndexOf(String str)
  判断某个子字符串在当前字符串中最后一次出现的索引（下标）。
  
  String replace(CharSequence target, CharSequence replacement)
  替换掉指定的字串。
  
  String[] split(String regex)
  拆分字符串。
  
  boolean startsWith(String prefix)
  判断某个字符串是否以某个子字符串开始。
  
  String substring(int beginIndex)
  截取字符串，参数是起始下标。
  
  String substring(int beginIndex, int endIndex);
  	beginIndex起始位置（包括）
  	endIndex结束位置（不包括）
  
  char[] toCharArray()
  将字符串转换成char数组。
  
  String toLowerCase()
  转换为小写。
  
  String toUpperCase()
  转换为大写。
  
  String trim()
  去除字符串前后空白。
  ```

- 静态方法

  ```
  String中只有一个方法是静态的，不需要new对象这个方法叫做valueOf
  作用：将“非字符串”转换成“字符串”
  ```

## 17.2 StringBuffer和StringBuilder

- StringBuffer/StringBuilder可以看做可变长度字符串;
- StringBuffer/StringBuilder初始化容量16;
- StringBuffer/StringBuilder是完成字符串拼接操作的，方法名：append();
- 频繁进行字符串拼接不建议使用“+”，因为会创建很多字符串对象，浪费空间;
- StringBuffer是线程安全的，StringBuilder是非线程安全的。

- 如何优化StringBuffer的性能？
  - 在创建StringBuffer的时候，预估计一下尽可能给定一个初始化容量，减少底层数组的扩容次数，以提高程序的执行效率。

## 17.3 八种基本数据类型对应的包装类

### 17.3.1 包装类存在有什么用？

- 方便编程。

### 17.3.2 八种包装类的类名是什么？

```
Byte
Short
Integer
Long
Float
Double
Boolean
Character

所有数字的父类为Number
```

### 17.3.3 什么是自动装箱和自动拆箱，代码怎么写？

- 自动装箱：基本数据类型自动转换成引用数据类型。

- 自动拆箱：引用数据类型自动转换成基本数据类型。

  ```
  Integer x = 100; // x里面并不是保存100，保存的是100这个对象的内存地址。
  Integer y = 100;
  System.out.println(x == y); // true
  
  Integer x = 128;
  Integer y = 128;
  System.out.println(x == y); // false
  ```

## 17.3.4 Integer类常用方法

```
Integer.valueOf()
Integer.parseInt("123")
Integer.parseInt("中文") : NumberFormatException
```

## 17.3.5 Integer String int三种类型互相转换

![image-20240604100718620](assets/image-20240604100718620.png)

## 17.4 日期类

### 17.4.1 获取系统当前时间

```
Date d = new Date();
```

### 17.4.2 日期格式化：Date → String

```
yyyy-MM-dd HH:mm:ss SSS

SimpleDateFormat sdf = new SimpleDate("yyyy-MM-dd HH:mm:ss SSS");

String s = sdf.format(new Date());
```

### 17.4.3 日期格式化：String → Date

```
SimpleDateFormat sdf = new SimpleDate("yyyy-MM-dd HH:mm:ss");

Date d = sdf.parse("2008-08-08 08:08:08");
```

### 17.4.4 获取毫秒数：System.currentTimeMillis()

```
表示从北京时间1970-01-01 08:00:00到当前时间的毫秒数。

Date的另一个构造方法，利用毫秒数创建对象：new Date(毫秒数)

long begin = System.currentTimeMillis();

Date d = new Date(begin - 1000 * 60 * 60 * 24); // 获取昨天这个时候的时间
```

## 17.5 数字类

### 17.5.1 DecimalFormat数字格式化

```
###,###.## 表示加入千分位，保留两个小数。
###,###.0000 表示加入千分位，保留4个小数，不够补0
```

### 17.5.2 BigDecimal

- 财务软件中通常使用BigDecimal

## 17.6 随机数类

### 17.6.1 怎么产生int类型随机数。

```
Random r = new Random();
int i = r.nextInt();
```

### 17.6.2 怎么产生某个范围之内的int类型随机数。

```
Random r = new Random();
int i = r.nextInt(101); // 产生[0-100]的随机数。
```

## 17.7 枚举类

- 枚举是一种引用数据类型。

- 枚举编译之后也是class文件。

- 枚举类型怎么定义？

  ```
  enum 枚举类型名{
  	枚举值,枚举值2,枚举值3
  }
  ```

- 当一个方法执行结果超过两种情况，并且是一枚一枚可以列举出来的时候，建议返回值类型设计为枚举类型。例如：颜色、四季、星期等都可以使用枚举类型。

```java
public class EnumTest01 {
    public static void main(String[] args) {
        Season res = Season.SPRING;
        System.out.println(res);
    }
}
enum Season{
    SPRING, SUMMER, AUTUMN, WINTER;
}
```

# 18.异常处理

## 18.1 异常处理机制

- java中异常的作用是：增强程序健壮性。
- java中异常以类和对象的形式存在。

## 18.2 异常的继承结构

异常在java中以类和对象的形式存在。那么异常的继承结构是怎样的？我们可以使用UML图来描述一下继承结构。画UML图有很多工具，例如：Rational Rose（收费的）、starUML等....   

<img src="assets/image-20240605091020585.png" alt="image-20240605091020585" style="zoom:33%;" />

- Object下有Throwable（可抛出的），下面有两个分支；

  - Error（不可处理，直接退出JVM）；

  - Exception（可处理的），下面有两个分支；

    - Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。

    - RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）

- 编译时异常和运行时异常，都是发生在运行阶段，编译阶段异常是不会发生的。编译时异常因为什么而得名？

  - 因为编译时异常必须在编译(编写)阶段预先处理，如果不处理编译器报错，因此得名。所有异常都是在运行阶段发生的。因为只有程序运行阶段才可以new对象，因为异常的发生就是new异常对象。

- 编译时异常和运行时异常的区别？

  - 编译时异常一般发生的概率比较高。

    - 举个例子：你看到外面下雨了，倾盆大雨的。你出门之前会预料到：如果不打伞，我可能会生病（生病是一种异常）。而且这个异常发生的概率很高，所以我们出门之前要拿一把伞。“拿一把伞”就是对“生病异常”发生之前的一种处理方式。

    - 对于一些发生概率较高的异常，需要在运行之前对其进行预处理。

  - 运行时异常一般发生的概率比较低。
    - 举个例子：小明走在大街上，可能会被天上的飞机轮子砸到。被飞机轮子砸到也算一种异常。但是这种异常发生概率较低。在出门之前你没必要提前对这种发生概率较低的异常进行预处理。如果你预处理这种异常，你将活的很累。假设你在出门之前，你把能够发生的异常都预先处理，你这个人会更加的安全，但是你这个人活的很累。
  - 假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，所有的异常都需要在编写程序阶段对其进行预处理，将是怎样的效果呢？
    - 首先，如果这样的话，程序肯定是绝对的安全的。但是程序员编写程序太累，代码到处都是处理异常的代码。

  - 编译时异常还有其他名字：

    - 受检异常：CheckedException

    - 受控异常

  - 运行时异常还有其它名字：
    - 未受检异常：UnCheckedException
    - 非受控异常

  - 再次强调：所有异常都是发生在运行阶段的。

## 18.3 异常的处理方式

```java
/*
以下代码报错的原因是什么？
    因为doSome()方法声明位置上使用了：throws ClassNotFoundException
    而ClassNotFoundException是编译时异常。必须编写代码时处理，没有处理
    编译器报错。
 */
public class ExceptionTest04 {
    public static void main(String[] args) {
        // main方法中调用doSome()方法
        // 因为doSome()方法声明位置上有：throws ClassNotFoundException
        // 我们在调用doSome()方法的时候必须对这种异常进行预先的处理。
        // 如果不处理，编译器就报错。
        //编译器报错信息： Unhandled exception: java.lang.ClassNotFoundException
        //doSome();  //此处导致报错
    }

    /**
     * doSome方法在方法声明的位置上使用了：throws ClassNotFoundException
     * 这个代码表示doSome()方法在执行过程中，有可能会出现ClassNotFoundException异常。
     * 叫做类没找到异常。这个异常直接父类是：Exception，所以ClassNotFoundException属于编译时异常。
     * @throws ClassNotFoundException
     */
    public static void doSome() throws ClassNotFoundException{
        System.out.println("doSome!!!!");
    }

}
```

- 第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级。谁调用我，我就抛给谁。抛给上一级。

- 第二种方式：使用try..catch语句进行异常的捕捉。这件事发生了，谁也不知道，因为我给抓住了。

  ```java
  public class ExceptionTest05 {
      // 第一种处理方式：在方法声明的位置上继续使用：throws，来完成异常的继续上抛。抛给调用者。
      // 上抛类似于推卸责任。（继续把异常传递给调用者。）
      /*
      public static void main(String[] args) throws ClassNotFoundException {
          doSome();
      }
       */
  
      // 第二种处理方式：try..catch进行捕捉。
      // 捕捉等于把异常拦下了，异常真正的解决了。（调用者是不知道的。）
      public static void main(String[] args) {
          try {
              doSome();
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
      }
  
      public static void doSome() throws ClassNotFoundException{
          System.out.println("doSome!!!!");
      }
  
  }
  
  ```

  - 举个例子：我是某集团的一个销售员，因为我的失误，导致公司损失了1000元，“损失1000元”这可以看做是一个异常发生了。我有两种处理方式，

    - 第一种方式：我把这件事告诉我的领导【异常上抛 张三 --> 李四 ---> 王五 --> CEO】
    - 第二种方式：我自己掏腰包把这个钱补上【异常的捕捉】

  - 思考：异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要对这个异常继续处理，那么调用者处理这个异常同样有两种处理方式。

  - 注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续向上抛，抛给了调用者JVM，JVM知道这个异常发生，只有一个结果。终止java程序的执行。

  - 注意：

    - 只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行。

    - 另外需要注意，try语句块中的某一行出现异常，该行后面的代码不会执行。

    - try..catch捕捉异常之后，后续代码可以执行。

      ```java
      public class ExceptionTest03 {
          public static void main(String[] args) {
              System.out.println("main begin:");
              try {
                  m1();
                  System.out.println("after m1 ");//不会执行
              } catch (FileNotFoundException e) {
                  // 获取异常的简单描述信息
                  String msg = e.getMessage();
                  System.out.println(msg); //C:\jetns-agent.jar (系统找不到指定的文件。)
      
              }
      
              // 这里程序不耽误执行，很健壮。《服务器不会因为遇到异常而宕机。》
              System.out.println("main end!");
          }
      
          private static void m1() throws FileNotFoundException {
              System.out.println("m1 begin:");
              m2();
              System.out.println("m1 end");//不会执行
          }
      
          private static void m2() throws FileNotFoundException {
              System.out.println("m2 begin:");
              m3();
              System.out.println("m2 end");//不会执行
          }
      
          private static void m3() throws FileNotFoundException {
              System.out.println("m3 begin:");
              new FileInputStream("C:\\jetns-agent.jar");
              System.out.println("m3 end");//不会执行
          }
      }
      ```

      

  - 在以后的开发中，处理编译时异常，应该上报还是捕捉呢，怎么选？

    - 如果希望调用者来处理，选择throws上报。其它情况使用捕捉的方式。

## 18.4 异常对象有两个非常重要的方法

```
获取异常简单的描述信息：
String msg = exception.getMessage();

打印异常追踪的堆栈信息：
exception.printStackTrace(); // 最常使用的是这个
```

```java
public class ExceptionTest08 {
    public static void main(String[] args) {
        // 这里只是为了测试getMessage()方法和printStackTrace()方法。
        // 这里只是new了异常对象，但是没有将异常对象抛出。JVM会认为这是一个普通的java对象。
        NullPointerException e = new NullPointerException("空指针异常fdsafdsafdsafds");

        // 获取异常简单描述信息：这个信息实际上就是构造方法上面String参数。
        String msg = e.getMessage(); //空指针异常fdsafdsafdsafds
        System.out.println(msg);

        // 打印异常堆栈信息
        // java后台打印异常堆栈追踪信息的时候，采用了异步线程的方式打印的。
        e.printStackTrace();

        for(int i = 0; i < 1000; i++){
            System.out.println("i = " + i);
        }

        System.out.println("Hello World!");
    }
}
```

- 我们以后查看异常的追踪信息，我们应该怎么看，可以快速的调试程序呢？

  - 异常信息追踪信息，从上往下一行一行看。

  - 但是需要注意的是：SUN写的代码就不用看了(看包名就知道是自己的还是SUN的。)。

  - 主要的问题是出现在自己编写的代码上。

    ```java
    public class ExceptionTest09 {
        public static void main(String[] args) {
            try {
                m1();
            } catch (FileNotFoundException e) {
                // 获取异常的简单描述信息
                String msg = e.getMessage();
                System.out.println(msg); //C:\jetns-agent.jar (系统找不到指定的文件。)
    
                //打印异常堆栈追踪信息！！！
                //在实际的开发中，建议使用这个。养成好习惯！
                // 这行代码要写上，不然出问题你也不知道！
                //e.printStackTrace();
                /*
                java.io.FileNotFoundException: C:\jetns-agent.jar (系统找不到指定的文件。)
                    at java.base/java.io.FileInputStream.open0(Native Method)
                    at java.base/java.io.FileInputStream.open(FileInputStream.java:213)
                    at java.base/java.io.FileInputStream.<init>(FileInputStream.java:155)
                    at java.base/java.io.FileInputStream.<init>(FileInputStream.java:110)
                    at com.bjpowernode.javase.exception.ExceptionTest09.m3(ExceptionTest09.java:31)
                    at com.bjpowernode.javase.exception.ExceptionTest09.m2(ExceptionTest09.java:27)
                    at com.bjpowernode.javase.exception.ExceptionTest09.m1(ExceptionTest09.java:23)
                    at com.bjpowernode.javase.exception.ExceptionTest09.main(ExceptionTest09.java:14)
                    因为31行出问题导致了27行
                    27行出问题导致23行
                    23行出问题导致14行。
                    应该先查看31行的代码。31行是代码错误的根源。
                 */
            }
    
            // 这里程序不耽误执行，很健壮。《服务器不会因为遇到异常而宕机。》
            System.out.println("Hello World!");
        }
    
        private static void m1() throws FileNotFoundException {
            m2();
        }
    
        private static void m2() throws FileNotFoundException {
            m3();
        }
    
        private static void m3() throws FileNotFoundException {
            new FileInputStream("C:\\jetns-agent.jar");
        }
    }
    
    ```

## 18.5 关于try..catch中的finally子句

- 在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。

- finally子句必须和try一起出现，不能单独编写。

- finally语句通常使用在哪些情况下呢？

  - 通常在finally语句块中完成资源的释放/关闭。

  - 因为finally中的代码比较有保障。

  - 即使try语句块中的代码出现异常，finally中代码也会正常执行。

    ```java
    public class ExceptionTest10 {
        public static void main(String[] args) {
            FileInputStream fis = null; // 声明位置放到try外面。这样在finally中才能用。
            try {
                // 创建输入流对象
                fis = new FileInputStream("D:\\course\\02-JavaSE\\document\\JavaSE进阶讲义\\JavaSE进阶-01-面向对象.pdf");
                // 开始读文件....
    
                String s = null;
                // 这里一定会出现空指针异常！
                s.toString();
                System.out.println("hello world!");
    
                // 流使用完需要关闭，因为流是占用资源的。
                // 即使以上程序出现异常，流也必须要关闭！
                // 放在这里有可能流关不了。
                //fis.close();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch(IOException e){
                e.printStackTrace();
            } catch(NullPointerException e) {
                e.printStackTrace();
            } finally {
                System.out.println("hello 浩克！");
                // 流的关闭放在这里比较保险。
                // finally中的代码是一定会执行的。
                // 即使try中出现了异常！
                if (fis != null) { // 避免空指针异常！
                    try {
                        // close()方法有异常，采用捕捉的方式。
                        fis.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
    
            System.out.println("hello kitty!");
    
        }
    }
    
    ```

- 阅读程序：说出以下程序的执行顺序？

  ```java
  /*
  finally语句：
      放在finally语句块中的代码是一定会执行的【再次强调！！！】
   */
  public class ExceptionTest11 {
      public static void main(String[] args) {
          /*
          try和finally，没有catch可以吗？可以。
              try不能单独使用。
              try finally可以联合使用。
          以下代码的执行顺序：
              先输出try...
              再输出finally...
              最后执行 return （return语句只要执行方法必然结束。）
           */
          try {
              System.out.println("try...");
              return;
          } finally {
              // finally中的语句会执行。能执行到。
              System.out.println("finally...");
          }
  
          // 这里不能写语句，因为编译器检测到在这个代码执行之前return会先执行，故该代码是无法执行到的。
          //System.out.println("Hello World!");
      }
  }
  ```

- System.exit(0)表示退出JVM，退出JVM之后，finally语句中的代码就不执行了！

  ```java
  public class ExceptionTest12 {
      public static void main(String[] args) {
          try {
              System.out.println("try...");
              // 退出JVM
              System.exit(0); // 退出JVM之后，finally语句中的代码就不执行了！
          } finally {
              System.out.println("finally...");
          }
      }
  }
  ```

- finally面试题

  ```
  /*
  finally面试题
   */
  public class ExceptionTest13 {
      public static void main(String[] args) {
          int result = m();
          System.out.println(result); //100
      }
  
      /*
      java语法规则（有一些规则是不能破坏的，一旦这么说了，就必须这么做！）：
          java中有一条这样的规则：
              方法体中的代码必须遵循自上而下顺序依次逐行执行（亘古不变的语法！）
          java中有一条语法规则：
              return语句一旦执行，整个方法必须结束（亘古不变的语法！）
       */
      public static int m(){
          int i = 100;
          try {
              // 这行代码出现在int i = 100;的下面，所以最终结果必须是返回100
              // return语句还必须保证是最后执行的。一旦执行，整个方法结束。
              return i;
          } finally {
              i++;
          }
      }
  }
  
  /*
  反编译之后的效果
  public static int m(){
      int i = 100;
      int j = i;
      i++;
      return j;
  }
   */
  ```

## 18.6 final、finally、finalize有什么区别？

- final 关键字

  - final修饰的类无法继承

  - final修饰的方法无法覆盖

  - final修饰的变量不能重新赋值。

- finally 关键字  

  - 和try一起联合使用。

  - finally语句块中的代码是必须执行的。

- finalize 标识符

  - 是一个Object类中的方法名。

  - 这个方法是由垃圾回收器GC负责调用的。

## 18.7 自定义异常（重点）

SUN提供的JDK内置的异常肯定是不够的用的。在实际的开发中，有很多业务，这些业务出现异常之后，JDK中都是没有的。和业务挂钩的。那么异常类我们程序员可以自己定义吗？可以。

### 18.7.1 在Java中如何自定义异常？

- 第一步：编写一个类继承Exception或者RuntimeException.

- 第二步：提供两个构造方法，一个无参数的，一个带有String参数的。

  ```java
  public class MyException extends Exception{ // 编译时异常
      public MyException(){
          super();
      }
      public MyException(String s){
          super(s);
      }
  }
  
  // 死记硬背。
  ```

### 18.7.2 异常在实际开发中的作用(例子必须掌握)

- 自定义栈操作异常类

  ```java
  /**
   * 栈操作异常：自定义异常！
   */
  public class MyStackOperationException extends Exception{ // 编译时异常！
  
      public MyStackOperationException(){
  
      }
  
      public MyStackOperationException(String s){
          super(s);
      }
  }
  ```

- 栈

  ```java
  /*
  	编写程序，使用一维数组，模拟栈数据结构。
  	要求：
  		1、这个栈可以存储java中的任何引用类型的数据。
  		2、在栈中提供push方法模拟压栈。（栈满了，要有提示信息。）
  		3、在栈中提供pop方法模拟弹栈。（栈空了，也有有提示信息。）
  		4、编写测试程序，new栈对象，调用push pop方法来模拟压栈弹栈的动作。
  		5、假设栈的默认初始化容量是10.（请注意无参数构造方法的编写方式。）
   */
  public class MyStack {
      // 向栈当中存储元素，我们这里使用一维数组模拟。存到栈中，就表示存储到数组中。
      // 因为数组是我们学习java的第一个容器。
      // 为什么选择Object类型数组？因为这个栈可以存储java中的任何引用类型的数据
      // new Animal()对象可以放进去，new Person()对象也可以放进去。因为Animal和Person的超级父类就是Object。
      // 包括String也可以存储进去。因为String父类也是Object。
      private Object[] elements;
  
      // 栈帧，永远指向栈顶部元素
      // 那么这个默认初始值应该是多少。注意：最初的栈是空的，一个元素都没有。
      //private int index = 0; // 如果index采用0，表示栈帧指向了顶部元素的上方。
      //private int index = -1; // 如果index采用-1，表示栈帧指向了顶部元素。
      private int index;
  
      /**
       * 无参数构造方法。默认初始化栈容量10.
       */
      public MyStack() {
          // 一维数组动态初始化
          // 默认初始化容量是10.
          this.elements = new Object[10];
          // 给index初始化
          this.index = -1;
      }
  
      /**
       * 压栈的方法
       * @param obj 被压入的元素
       */
      public void push(Object obj) throws MyStackOperationException {
          if(index >= elements.length - 1){
              // 改良之前
              //System.out.println("压栈失败，栈已满！");
              //return;
  
              // 创建异常对象
              //MyStackOperationException e = new MyStackOperationException("压栈失败，栈已满！");
              // 手动将异常抛出去！
              //throw e; //这里捕捉没有意义，自己new一个异常，自己捉，没有意义。栈已满这个信息你需要传递出去。
  
              // 合并（手动抛出异常！）
              throw new MyStackOperationException("压栈失败，栈已满！");
          }
          // 程序能够走到这里，说明栈没满
          // 向栈中加1个元素，栈帧向上移动一个位置。
          index++;
          elements[index] = obj;
          // 在声明一次：所有的System.out.println()方法执行时，如果输出引用的话，自动调用引用的toString()方法。
          System.out.println("压栈" + obj + "元素成功，栈帧指向" + index);
      }
  
      /**
       * 弹栈的方法，从数组中往外取元素。每取出一个元素，栈帧向下移动一位。
       * @return
       */
      public void pop() throws MyStackOperationException {
          if(index < 0){
              //System.out.println("弹栈失败，栈已空！");
              //return;
              throw new MyStackOperationException("弹栈失败，栈已空！");
          }
          // 程序能够执行到此处说明栈没有空。
          System.out.print("弹栈" + elements[index] + "元素成功，");
          // 栈帧向下移动一位。
          index--;
          System.out.println("栈帧指向" + index);
      }
  
      // set和get也许用不上，但是你必须写上，这是规矩。你使用IDEA生成就行了。
      // 封装：第一步：属性私有化，第二步：对外提供set和get方法。
      public Object[] getElements() {
          return elements;
      }
  
      public void setElements(Object[] elements) {
          this.elements = elements;
      }
  
      public int getIndex() {
          return index;
      }
  
      public void setIndex(int index) {
          this.index = index;
      }
  }
  
  ```

- 测试

  ```java
  // 测试改良之后的MyStack
  // 注意：最后这个例子，是异常最终要的案例。必须掌握。自定义异常在实际开发中的应用。
  public class ExceptionTest16 {
  
      public static void main(String[] args) {
  
          // 创建栈对象
          MyStack stack = new MyStack();
  
          // 压栈
          try {
              stack.push(new Object());
              stack.push(new Object());
              stack.push(new Object());
              stack.push(new Object());
              stack.push(new Object());
              stack.push(new Object());
              stack.push(new Object());
              stack.push(new Object());
              stack.push(new Object());
              stack.push(new Object());
              // 这里栈满了
              stack.push(new Object());
          } catch (MyStackOperationException e) {
              // 输出异常的简单信息。
              System.out.println(e.getMessage());
          }
  
          // 弹栈
          try {
              stack.pop();
              stack.pop();
              stack.pop();
              stack.pop();
              stack.pop();
              stack.pop();
              stack.pop();
              stack.pop();
              stack.pop();
              stack.pop();
              // 弹栈失败
              stack.pop();
          } catch (MyStackOperationException e) {
              System.out.println(e.getMessage());
          }
      }
  }
  
  ```

### 18.7.3 之前在讲解方法覆盖的时候，当时遗留了一个问题？

- 重写之后的方法不能比重写之前的方法抛出更多（更宽泛）的编译时异常，可以更少。

- 重写之后的方法可以比重写之前的方法抛出更多（更宽泛）的运行时异常。

  ```java
  class Animal {
      public void doSome(){
  
      }
  
      public void doOther() throws Exception{
  
      }
  }
  
  class Cat extends Animal {
  
      // 编译正常。
      public void doSome() throws RuntimeException{
  
      }
  
      // 编译报错。
      /*public void doSome() throws Exception{
  
      }*/
  
      // 编译正常。
      /*public void doOther() {
  
      }*/
  
      // 编译正常。
      /*public void doOther() throws Exception{
  
      }*/
  
      // 编译正常。
      public void doOther() throws NullPointerException{
  
      }
  }
  ```


# 19.集合

## 19.1 集合概述

- 什么是集合？有什么用？
  - 数组其实就是一个集合。集合实际上就是一个容器，可以来容纳其它类型的数据。

- 集合为什么说在开发中使用较多？
  - 集合是一个容器，是一个载体，可以一次容纳多个对象。
  - 在实际开发中，假设连接数据库，数据库当中有10条记录，那么假设把这10条记录查询出来，在java程序中会将10条数据封装成10个java对象，然后将10个java对象放到某一个集合当中，将集合传到前端，然后遍历集合，将一个数据一个数据展现出来。

- 集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址。（或者说集合中存储的是引用。）

  ```
  list.add(100); //自动装箱Integer
  注意：集合在java中本身是一个容器，是一个对象。集合中任何时候存储的都是“引用”。
  ```

  <img src="assets/image-20240606094453370.png" alt="image-20240606094453370" style="zoom:33%;" />

- 在java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。

  - 什么是数据结构？数据存储的结构就是数据结构。不同的数据结构，数据存储方式不同。例如：

    - 数组、二叉树、链表、哈希表...这些都是常见的数据结构。

          你往集合c1中放数据，可能是放到数组上了。
          你往集合c2中放数据，可能是放到二叉树上了。
          .....
          你使用不同的集合等同于使用了不同的数据结构。

  - 你在java集合这一章节，你需要掌握的不是精通数据结构。java中已经将数据结构实现了，已经写好了这些常用的集合类，你只需要掌握怎么用？在什么情况下选择哪一种合适的集合去使用即可。

    ```
    new ArrayList(); 创建一个集合，底层是数组。
    new LinkedList(); 创建一个集合对象，底层是链表。
    new TreeSet(); 创建一个集合对象，底层是二叉树。
    .....
    ```

- 集合在java JDK中哪个包下？

  ```
  java.util.*;
  所有的集合类和集合接口都在java.util包下。
  ```

- 为了掌握集合这块的内容，最好能将集合的继承结构图背会！
  - 集合整个这个体系是怎样的一个结构，你需要有印象。并且初始化容量和扩容倍数也背会，面试会问。

![54626ea2251f4b27b2721a6eb6d0c3be](assets/54626ea2251f4b27b2721a6eb6d0c3be.png)

![3cde4d53a67641d49728b185ec052793](assets/3cde4d53a67641d49728b185ec052793.png)

- 在java中集合分为两大类

  - 一类是单个方式存储元素：
    - 单个方式存储元素，这一类集合中超级父接口：java.util.Collection;

  - 一类是以键值对儿的方式存储元素：
    - 以键值对的方式存储元素，这一类集合中超级父接口：java.util.Map;

## 19.2 Collection接口

### 19.2.1 Collection接口中能存放什么元素？

- 没有使用“泛型”之前，Collection中可以存储Object的所有子类型。使用了“泛型”之后，Collection中只能存储某个具体的类型。

- Collection中什么都能存，只要是Object的子类型就行。（集合中不能直接存储基本数据类型，也不能存java对象，只是存储java对象的内存地址。）

### 19.2.2 Collection接口中的常用方法

- 这些方法一定要动手亲自去测，才能更好掌握

  ```
  boolean add(Object e) 向集合中添加元素
  int size()  获取集合中元素的个数
  void clear() 清空集合
  boolean contains(Object o) 判断当前集合中是否包含元素o，包含返回true，不包含返回false
  boolean remove(Object o) 删除集合中的某个元素。
  boolean isEmpty()  判断该集合中元素的个数是否为0
  Object[] toArray()  调用这个方法可以把集合转换成数组。【作为了解，使用不多。】
  ```

### 19.2.3 迭代器

- 迭代器的原理

  ![image-20240606103124144](assets/image-20240606103124144.png)

- 操作迭代器

  - 第一步：获取集合对象的迭代器对象Iterator

    ```
    Iterator it = c.iterator();
    ```

  - 第二步：通过以上获取的迭代器对象开始迭代/遍历集合。

    - 以下两个方法是迭代器对象Iterator中的方法：

      ```
      boolean hasNext()如果仍有元素可以迭代，则返回 true。
      Object next() 返回迭代的下一个元素。
      ```

    - 例1

      ```java
      public static void main(String[] args) {
          Collection c = new ArrayList();
          c.add(18);
          c.add(3.14);
          c.add(new Object());
          c.add(true);
          c.add("hello");
          c.add("hello");
          Iterator it = c.iterator();
          while(it.hasNext()){
              System.out.println(it.next());
          }
          /*
              输出：18     3.14     java.lang.Object@65b54208     true    hello    hello
              进一步验证了ArrayList集合类是有序可重复
          */
      ```

    - 例2：使用泛型时需要注意代码的写法

      ```java
      public static void main(String[] args) {
          Collection<Integer> list = new ArrayList<>();
          list.add(10);
          list.add(20);
          list.add(30);
          list.add(40);
          list.add(50);
          Iterator<Integer> it = list.iterator();
          while(it.hasNext()){
              Object o = it.next();
              if(o instanceof Integer){
                  Integer i = (Integer)o;
                  System.out.println(i);
              }
          }
      }
      ```

    - 例3

      ```JAVA
      public static void main(String[] args) {
              Collection c2 = new HashSet();
              c2.add(10);
              c2.add(20);
              c2.add(30);
              c2.add(40);
              c2.add(50);
              c2.add(60);
              Iterator it = c2.iterator();
              while(it.hasNext()){
                  System.out.println(it.next());
              }
              /*
                  输出：50  20  40  10  60  30
                  进一步验证了HashSet集合类无序不可重复。
               */
      }
      ```

- 迭代器的注意事项

  - 当集合的结构发生改变时，迭代器必须重新获取，如果还是用以前老的迭代器，会出现异常

    ```
    “java.util.ConcurrentModificationException”
    ```

  - 在迭代集合元素的过程中，不能调用集合对象的remove方法删除元素，因为删完后集合结构发生了改变，而迭代器并没有更新，必然会出现

    ```
    “java.util.ConcurrentModificationException”
    ```

  - 在迭代元素的过程当中，一定要使用迭代器Iterator的remove方法，删除元素，不要使用集合自带的remove方法删除元素。迭代器的remove方法会删除迭代器当前所指向的元素，并且自动更新迭代器。

### 19.2.4 Collection接口中的remove方法和contains方法底层都会调用equals

- 存放在一个集合中的类型，一定要重写equals方法。
- 一定要写测试程序测，并且看源码中到底是否调用了equals。

## 19.3 List接口

### 19.3.1 List接口中特有且常用的方法

```
void add(int index, Object element)
根据下标插入元素

Object remove(int index);
删除指定下标的元素

Object set(int index, Object element)
修改指定下标的元素

Object get(int index);
获取指定下标的元素

int indexOf(Object o);
获取元素o第一次出现时的下标

int lastIndexOf(Object o);
获取元素o最后一次出现时的下标
```

### 19.3.2 ArrayList类

- 默认初始化容量10（底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10。）

  - 底层是一个Object[]数组。

- 构造方法：

  ```
  new ArrayList();
  new ArrayList(20);
  ```

- ArrayList集合的扩容：增长到原容量的1.5倍。

  - ArrayList集合底层是数组，怎么优化？
    - 尽可能少的扩容，因为数组扩容效率比较低，建议在使用ArrayList集合的时候预估计元素的个数，给定一个初始化容量。
  - 数组优点
    - 检索效率比较高。每个元素占用空间大小相同，内存地址是连续的，知道首元素内存地址，然后知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高。
  - 数组缺点
    - 随机增删元素效率比较低。另外数组无法存储大数据量，因为很难找到一块非常巨大的连续的内存空间。

- 向数组末尾添加元素，效率很高，不受影响。

  - 面试官经常问的一个问题：这么多的集合中，你用哪个集合最多？
    - 答：ArrayList集合。因为往数组末尾添加元素，效率不受影响。另外，我们检索/查找某个元素的操作比较多。

- ArrayList集合是非线程安全的。

### 19.3.3 LinkedList类

- 链表的优点
  - 由于链表上的元素在空间存储上内存地址不连续，所以随机增删元素的时候不会有大量元素位移，因此随机增删效率较高。
  - 在以后的开发中，如果遇到随机增删集合中元素的业务比较多时，建议使用LinkedList。

- 链表的缺点：

  - 不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历，直到找到为止。所以LinkedList集合检索/查找的效率较低。

- ArrayList：把检索发挥到极致。（末尾添加元素效率还是很高的。）
- LinkedList：把随机增删发挥到极致。
- 现在一般加元素都是往末尾添加，所以ArrayList用的比LinkedList多。

### 19.3.4 Vector类

- Vector初始化容量是10.

  - 底层是数组。

- 扩容为原容量的2倍。

- Vector底层是线程安全的。

- 怎么得到一个线程安全的List：使用java.util.Collections工具类；

  ```
  Collections.synchronizedList(list);
  ```

## 19.4 JDK新特性

### 19.4.1 JDK5.0新特性：泛型

- 集合使用泛型来减少向下转型的操作。


- 怎么使用泛型？

  ```
  List<Animal> myList = new ArrayList<Animal>();
  ```

- 怎么自定义泛型？

  - 自定义泛型的时候，<> 尖括号中的是一个标识符，随便写。

  - java源代码中经常出现的是：

    ```
    <E>和<T>
    E是Element单词首字母。
    T是Type单词首字母。
    ```

  - 自定义泛型举例

    ```java
    public class MyList<T>{
            public T func(T elem){
                    return null;
            }
            public static void main(String[] args){
                   // 传入String时的情况，MyList中凡是有T的地方统统替换成String
                    MyList<String> mylist = new MyList<>();
                    String str = mylist.func("hello");
                    String str2 = mylist.func(99); // 编译报错，因为mylist.func()只接受String
                    
                    // 什么都不传时的情况，MyList中凡是有T的地方统统替换成Object
                    MyList mylist1 = new MyList();
            }
    }
    ```

### 19.4.2 JDK5.0新特性：foreach

- 对数组怎么遍历？

  ```
  for(int i : arr){
  	System.out.println(i);
  }
  ```

- 对集合怎么遍历？

  ```
  for(String s : list){
  	System.out.println(s);
  }
  ```

### 19.4.3 JDK8新特性：钻石表达式

```
List<String> list = new ArrayList<>();
类型自动推断！
```

## 19.5 Map接口

### 19.5.1 Map接口中的常用方法

```
V put(K key, V value) ；
向Map集合中添加键值对

V get(Object key)；
通过key获取value

void clear()；
清空Map集合

boolean containsKey(Object key)；
判断Map中是否包含某个key

boolean containsValue(Object value)；
判断Map中是否包含某个value

boolean isEmpty()；
判断Map集合中元素个数是否为0

V remove(Object key)；
通过key删除键值对

int size()；
获取Map集合中键值对的个数。

Collection<V> values()；
获取Map集合中所有的value，返回一个Collection

Set<K> keySet()；
获取Map集合所有的key（所有的键是一个set集合）

Set<Map.Entry<K,V>> entrySet()；
将Map集合转换成Set集合
```

![image-20240607105630549](assets/image-20240607105630549.png)

### 19.5.2 遍历Map集合的两种方式（精通）

- 获取所有key得到一个Set集合，遍历Set集合中每个key，通过key获取value

  ```java
  Map<Integer, String> m = new HashMap<Integer, String>();
  m.put(0, "张三");
  m.put(1, "李四");
  m.put(2, "王五");
  m.put(3, "赵六");
  Set<Integer> set = m.keySet();
  for(Integer key : set){
      System.out.println(m.get(key));
  }
  ```

- 获取Set<Map.Entry>即可，遍历Set集合中的Entry，调用entry.getKey()和entry.getValue()

  ```java
  Map<Integer, String> m = new HashMap<Integer, String>();
  m.put(0, "张三");
  m.put(1, "李四");
  m.put(2, "王五");
  m.put(3, "赵六");
  Set<Map.Entry<Integer, String>> set = m.entrySet();
  for(Map.Entry<Integer, String> entry : set){
      System.out.println(entry.getKey() + "----" + entry.getValue());
  }
  ```

### 19.5.3 HashMap类

- HashMap集合底层是哈希表的数据结构

  - 哈希表是一个数组和单向链表的结合体，数组在查询方面效率很高，随机增删方面效率很低。单向链表在随机增删方面效率较高，在查询方面效率很低。哈希表将以上的两种数据结构融合在一起，充分发挥它们各自的优点。
  - 哈希表的随机增删，以及查询效率都很高是因为增删是在链表上完成，查询也不需要都扫描，只需要部分扫描。

- HashMap集合底层的源代码

  ```java
  public class HashMap{
      // HashMap底层实际上就是一个数组。（一维数组）
      Node<K,V>[] table;
     
      // 静态的内部类HashMap.Node
      static class Node<K,V> {
          final int hash; // 哈希值（哈希值是key的hashCode()方法的执行结果。hash值通过哈希函数/算法，可以转换存储成数组的下标。）
          final K key; // 存储到Map集合中的那个key
          V value; // 存储到Map集合中的那个value
          Node<K,V> next; // 下一个节点的内存地址。
      }
  }
  ```

  - 哈希表是个一维数组，这个数组中每一个元素是一个单向链表。（数组和链表的结合体。）

- map.put(k,v)、v = map.get(k) 这两个方法的实现原理，是必须掌握的

  ![image-20240608092902787](assets/image-20240608092902787.png)

  - map.put(k,v)实现原理：
    - 先将k,v封装到Node对象当中作为一个新结点；
    - 底层会调用k的hashCode()方法得出hash值；
    - 通过哈希算法将hash值转换成数组的下标，下标位置上如果没有任何元素（单向链表），就把Node对象添加到这个位置上。如果下标对应位置上有元素（单向链表），此时会拿着k和单向链表上每一个节点中的k进行equals，如果所有的equals方法返回的都是false，那么这个新结点将会被添加到链表的末尾。如果其中有一个equals返回了true，那么这个节点的value将会被覆盖。
  - v=map.get(k)实现原理：
    - 底层会调用k的hashCode()方法得出hash值；
    - 通过哈希算法将hash值转换成数组下标，下标位置上如果没有任何元素（单向链表），返回null。如果下标对应位置上有元素（单向链表），此时会拿着k和单向链表上每一个节点中的k进行equals，如果所有的equals方法返回的都是false，那么get方法返回null。如果其中有一个equals返回了true，那么此时这个结点的value就是我们要找的value，get方法最终返回这个要找的value。

- 通过讲解可以得出HashMap集合的key，会先后调用两个方法，一个方法是hashCode()，一个方法是equal(), 那么这两个方法都需要进行重写。
  - 注意：同一个单向链表上所有结点的hash相同，因为他们的数组下标是一样的，但同一个链表上k和k的equals方法肯定返回的是false，都不相等。
- HashMap集合的key部分特点
  - 无序，不可重复。无序是因为不一定挂到哪个单向链表上，不可重复是因为equals方法来保证HashMap集合的key不可重复，如果key重复了，value会覆盖。
  - 重点：放在HashMap集合key部分的元素其实就是放到HashSet集合中了，所以放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写hashCode和equals方法。
- 哈希表HashMap使用不当时无法发挥性能！
  - 假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层哈希表变成了纯单向链表。这种情况我们成为：散列分布不均匀。
  - 什么是散列分布均匀？
    - 假设有100个元素，10个单向链表，那么每个单向链表上有10个节点，这是最好的，是散列分布均匀的。
  - 假设将所有的hashCode()方法返回值都设定为不一样的值，可以吗，有什么问题？
    - 不行，因为这样的话导致底层哈希表就成为一维数组了，没有链表的概念了。也是散列分布不均匀。
    - 散列分布均匀需要你重写hashCode()方法时有一定的技巧。
- HashMap集合的默认初始化容量是16，默认加载因子是0.75
  - 这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。
  - 重点，记住：HashMap集合初始化容量必须是2的倍数，这也是官方推荐的，这是因为达到散列均匀，为了提高HashMap集合的存取效率，所必须的。
- 向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！equals方法有可能调用，也有可能不调用。
  - 拿put(k,v)举例，什么时候equals不会调用？
    - k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成数组下标。数组下标位置上如果是null，equals不需要执行。
  - 拿get(k)举例，什么时候equals不会调用？
    - k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成数组下标。数组下标位置上如果是null，equals不需要执行。

- 如果一个类的equals方法重写了，那么hashCode()方法必须重写
  - 并且equals方法返回如果是true，hashCode()方法返回的值必须一样。equals方法返回true表示两个对象相同，在同一个单向链表上比较。那么对于同一个单向链表上的节点来说，他们的哈希值都是相同的。所以hashCode()方法的返回值也应该相同。
  - hashCode()方法和equals()方法不用研究了，直接使用IDEA工具生成，但是这两个方法需要同时生成。
  - 记住：放在HashMap集合key部分的，以及放在HashSet集合中的元素，需要同时重写hashCode方法和equals方法。
- HashMap集合key部分允许null吗？
  - 允许，但是要注意HashMap集合的key null值只能有一个。有可能面试的时候遇到这样的问题。

### 19.5.4 HashTable类

| **HashMap**           | **Hashtable**           |
| --------------------- | ----------------------- |
| 初始化容量16，扩容2倍 | 初始化容量11，扩容2倍+1 |
| 非线程安全            | 线程安全                |
| key和value可以为null  | key和value都不能是null  |

### 19.5.5 Properties类

- Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型。以下是它常用的两个方法：

  ```
  setProperty(String key, String value);
  存放键值对。
  
  getProperty(String key);
  通过键来取值。
  ```

### 19.5.6 TreeMap类

- TreeMap和TreeSet是可排序的集合类，当TreeMap的key或者TreeSet集合中它们存入自定义数据类型元素的时候，如果该自定义数据类型没有实现Comparable接口，自定义数据类型就无法排序，会报告异常。

  ```java
  public class TreeSetTest02 {
      public static void main(String[] args) {
          TreeSet<Student> ts = new TreeSet<>();
          Student s1 = new Student(8);
          Student s2 = new Student(4);
          Student s3 = new Student(9);
          Student s4 = new Student(5);
          ts.add(s1);
          ts.add(s1);
          ts.add(s2);
          ts.add(s3);
      }
  }
  class Student{
      public int age;
  
      public Student(){}
      public Student(int age) {
          this.age = age;
      }
  
      @Override
      public String toString() {
          return "Student{" +
                  "age=" + age +
                  '}';
      }
  }
  
  /*
  java.lang.ClassCastException: class com.lzk.test12.Student cannot be cast to class java.lang.Comparable (com.lzk.test12.Student is in unnamed module of loader 'app'; java.lang.Comparable is in module java.base of loader 'bootstrap')
  */
  ```

- 当我们实现Comparable接口并重写接口中的compareTo方法后，代码及运行结果如下：

  ```java
  public class TreeSetTest02 {
      public static void main(String[] args) {
          TreeSet<Student> ts = new TreeSet<>();
          Student s1 = new Student(8);
          Student s2 = new Student(4);
          Student s3 = new Student(9);
          Student s4 = new Student(5);
          ts.add(s1);
          ts.add(s1);
          ts.add(s2);
          ts.add(s3);
  
          for(Student s : ts){
              System.out.println(s);
          }
  
      }
  }
  class Student implements Comparable<Student>{
      public int age;
  
      public Student(){}
      public Student(int age) {
          this.age = age;
      }
  
      @Override
      public String toString() {
          return "Student{" +
                  "age=" + age +
                  '}';
      }
  
      @Override
      public int compareTo(Student o) {
          return this.age - o.age;
      }
  }
  
  /*
  Student{age=4}
  Student{age=8}
  Student{age=9}
  */
  ```

- 排序规则的写法，例如想要让学生按年龄升序排序，年龄相同再按照姓名升序排序：

  ```java
  public class TreeSetTest02 {
      public static void main(String[] args) {
          TreeSet<Student> ts = new TreeSet<>();
          Student s1 = new Student("zhangsan", 8);
          Student s2 = new Student("lisi", 4);
          Student s3 = new Student("wangwu", 9);
          Student s4 = new Student("zhaoliu", 5);
          Student s5 = new Student("zhangwei", 8);
          ts.add(s1);
          ts.add(s2);
          ts.add(s3);
          ts.add(s4);
          ts.add(s5);
  
          for(Student s : ts){
              System.out.println(s);
          }
  
      }
  }
  class Student implements Comparable<Student>{
      public String name;
      public int age;
  
      public Student(){}
  
      public Student(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      @Override
      public String toString() {
          return "name:"+this.name+" , age:" + this.age;
      }
  
      @Override
      public int compareTo(Student o) {
          if(this.age == o.age){
              return this.name.compareTo(o.name);
          }else{
              return this.age - o.age;
          }
      }
  }
  
  /*
  name:lisi , age:4
  name:zhaoliu , age:5
  name:zhangsan , age:8
  name:zhangwei , age:8
  name:wangwu , age:9
  */
  ```

- TreeMap的底层是一棵平衡二叉树（平衡二叉树也是二叉排序树）

- TreeMap的key或者TreeSet集合中的自定义数据类型元素要想排序，有两种实现方式：

  - 第一种：实现java.lang.Comparable接口

    - 当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现Comparable接口。


    - 写法：用我的自定义类继承Comparable接口，实现接口中的compareTo方法。


  - 第二种：单独编写一个比较器Comparator接口

    - 如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。

      - 写法1：先写一个自定义类，再写一个比较器类，new TreeSet时候构造方法中传入比较器对象

        ```java
        public class TreeSetTest03 {
            public static void main(String[] args) {
                TreeSet<Person> ts = new TreeSet<>(new PersonCompare());
                ts.add(new Person(20));
                ts.add(new Person(10));
                ts.add(new Person(28));
                ts.add(new Person(5));
                for(Person s : ts){
                    System.out.println(s);
                }
            }
        }
        class Person{
            public int age;
            public Person(){}
            public Person(int age) {
                this.age = age;
            }
            @Override
            public String toString() {
                return "Person{" + "age=" + age + '}';
            }
        }
        class PersonCompare implements Comparator<Person> {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.age - o2.age;
            }
        }
        
        ```

      - 写法2：匿名内部类方式

        ```java
        public class TreeSetTest03 {
            public static void main(String[] args) {
                TreeSet<Person> ts = new TreeSet<>(new Comparator<Person>() {
                    @Override
                    public int compare(Person o1, Person o2) {
                        return o1.age - o2.age;
                    }
                });
                ts.add(new Person(20));
                ts.add(new Person(10));
                ts.add(new Person(28));
                ts.add(new Person(5));
                for(Person s : ts){
                    System.out.println(s);
                }
            }
        }
        class Person{
            public int age;
            public Person(){}
            public Person(int age) {
                this.age = age;
            }
            @Override
            public String toString() {
                return "Person{" + "age=" + age + '}';
            }
        }
        ```

## 19.6 集合工具类Collections

- Collections中的常用方法

  ```
  Collections.synchronizedList(List list)方法;
  得到一个线程安全的list。
  
  Collections.sort(List list)方法
  Collections.sort(List list, Comparetor comparetor)方法
  用于对List集合进行排序；
  要求集合中元素实现Comparable接口或写一个继承Comparetor的比较器类或匿名内部类。
  ```

  - 例1

    ```java
    public class CollectionsTest01 {
        public static void main(String[] args) {
            List<String> list1 = new ArrayList<>();
            list1.add("zhangsan");
            list1.add("lisi");
            list1.add("wangwu");
            list1.add("zhaoliu");
            list1.add("zhangwei");
            for(String s : list1){
                System.out.println(s);
            }
            System.out.println("=============排序后==============");
            Collections.sort(list1);
            for(String s : list1){
                System.out.println(s);
            }
        }
    }
    ```

  - 例2

    ```java
    public class CollectionsTest02 {
        public static void main(String[] args) {
            List<Student> list = new ArrayList<>();
            list.add(new Student(18));
            list.add(new Student(16));
            list.add(new Student(20));
            list.add(new Student(11));
    
            for(Student s : list){
                System.out.println(s);
            }
    
            System.out.println("=============排序后==============");
            Collections.sort(list, new StudentComparator());
    
            for(Student s : list){
                System.out.println(s);
            }
        }
    }
    class Student{
        public int age;
        public Student(){}
        public Student(int age) {
            this.age = age;
        }
    
        @Override
        public String toString() {
            return "Student{" +
                    "age=" + age +
                    '}';
        }
    }
    
    class StudentComparator implements Comparator<Student> {
        @Override
        public int compare(Student o1, Student o2) {
            return o1.age - o2.age;
        }
    }
    ```

## 19.7 集合这块最主要掌握的内容（动手测试）

- ArrayList

  - 每个集合对象的创建（new）

  - 向集合中添加元素

  - 从集合中取出某个元素

  - 遍历集合

- LinkedList

  - 同上


- HashSet

  - 每个集合对象的创建（new）

  - 向集合中添加元素

  - 从集合中取出某个元素

  - 遍历集合

  - 测试HashSet集合的特点：无序不可重复。

- TreeSet

  - 每个集合对象的创建（new）


  - 向集合中添加元素

  - 从集合中取出某个元素

  - 遍历集合

  - 测试TreeSet集合中的元素是可排序的。

  - 测试TreeSet集合中存储的类型是自定义的。

  - 测试实现Comparable接口的方式

  - 测试实现Comparator接口的方式（最好测试以下匿名内部类的方式）

- HashMap

  - 每个集合对象的创建（new）


  - 向集合中添加元素

  - 从集合中取出某个元素

  - 遍历集合

- Properties
  - 测试HashTable不用测，直接测试这个。

- TreeMap
  - 测试TreeSet时候测一下TreeMap。

# 20.IO流

## 20.1 什么是IO流，什么是IO？

![image-20240609095051993](assets/image-20240609095051993.png)

- I：Input，将文件从硬盘**输入**或**读入**内存。
- O：Output，将文件从内存**输出**或**写入**硬盘。
- 通过IO可以完成硬盘文件的读和写。

## 20.2 IO流的分类

- 按照流的方向进行分类（以内存作为参照物）
  - 输入流：往内存中去，叫做输入(Input)。或者叫做读(Read)。
  - 输出流：从内存中出来，叫做输出(Output)。或者叫做写(Write)。

- 按照读取数据方式不同进行分类：

  - 字节流

    - 有的流是按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制位。这种流是万能的，什么类型的文件都可以读取。包括：文本文件，图片，声音文件，视频文件等....

    - 例：假设文件file1.txt，内容为“a中国bc张三fe”，采用字节流的话是这样读的：

      ```
      第一次读：一个字节，正好读到'a'
      第二次读：一个字节，正好读到'中'字符的一半。
      第三次读：一个字节，正好读到'中'字符的另外一半。
      ```

  - 字符流

    - 有的流是按照字符的方式读取数据的，一次读取一个字符，这种流是为了方便读取普通文本文件而存在的，这种流不能读取：图片、声音、视频等文件。只能读取纯文本文件，连word文件都无法读取。

    - 例：假设文件file1.txt，内容为“a中国bc张三fe”，采用字符流的话是这样读的：

      ```
      第一次读：'a'字符（'a'字符在windows系统中占用1个字节。）
      第二次读：'中'字符（'中'字符在windows系统中占用2个字节。）
      ```

## 20.3 IO流的学习方式

- Java中的IO流都已经写好了，我们程序员不需要关心,我们最主要还是掌握在java中已经提供了哪些流，每个流的特点是什么，每个流对象上的常用方法有哪些。

- java中所有的流都是在：java.io.*;下。


- java中主要还是研究：怎么new流对象。调用流对象的哪个方法是读，哪个方法是写。

## 20.4 Java IO流这块有四大家族

- 四大家族的首领

  | java.io.InputStream      | **字节输入流** |
  | ------------------------ | -------------- |
  | **java.io.OutputStream** | **字节输出流** |
  | **java.io.Reader**       | **字符输入流** |
  | **java.io.Writer**       | **字符输出流** |

  - 四大家族的首领都是抽象类。(abstract class)
  - 所有的流都实现了java.io.Closeable接口，都是可关闭的，都有close()方法。
    - 流毕竟是一个管道，这个是内存和硬盘之间的通道，用完之后一定要关闭，不然会耗费(占用)很多资源。养成好习惯，用完流一定要关闭。
  - 所有的输出流都实现了java.io.Flushable接口，都是可刷新的，都有flush()方法。
    - 养成一个好习惯，输出流在最终输出之后，一定要记得flush()刷新一下。这个刷新表示将通道/管道当中剩余未输出的数据强行输出完（清空管道！）刷新的作用就是清空管道。
    - 注意：如果没有flush()可能会导致丢失数据。
  - 注意：在java中只要“类名”以Stream结尾的都是字节流。以“Reader/Writer”结尾的都是字符流。

## 20.5 Java.io包下需要掌握的流有16个

### 20.5.1 文件专属

```
java.io.FileInputStream（掌握）
java.io.FileOutputStream（掌握）
java.io.FileReader
java.io.FileWriter
```

- java.io.FileInputStream

  - 构造方法

    ```
    FileInputStream(String name);
    通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。
    注：文件不存在会自动创建名为name的文件。
    ```

  - 常用方法

    ```
    void close() ：关闭此文件输入流并释放与此流有关的所有系统资源。  
    int read()：一次读取一个字节，返回当前读取到的字符的ascii码，当读到文件流末尾返回-1；
    
    int read(byte[] b) ：从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中
    返回读入缓冲区的总字节数，如果因为已到达文件末尾而没有更多数据，则为 -1。
    
    int available()：返回流当中剩余的没有读到的字节数量。
    long skip(long n)：跳过几个字节不读。
    ```

  - 固定写法

    ```java
    FileInputStream fis = null;
    try {
        fis = new FileInputStream("文件路径");
        ...
    }catch () {
        e.printStackTrace();
    }finally {
        if (fis != null) {
            try {
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ```

    - 例1：基本的读取文件的例子

      ```java
      public class FileInputStreamTest01 {
          public static void main(String[] args) {
              FileInputStream fis = null;
              try {
                  fis = new FileInputStream("tempFile.txt");
                  // 注意：文件中如果有换行，该换行符表示回车+换行 等价于\r\n
                  // '\r'是回车，'\n'是换行，前者使光标到行首，后者使光标下移一格。通常用的Enter是两个加起来。
                  int readCount = 0;
                  byte[] bytes = new byte[4];
                  while((readCount = fis.read(bytes)) != -1){
                      System.out.print(new String(bytes, 0, readCount));
                  }
              } catch (FileNotFoundException e) {
                  e.printStackTrace();
              } catch (IOException e) {
                  e.printStackTrace();
              } finally {
                  if (fis != null) {
                      try {
                          fis.close();
                      } catch (IOException e) {
                          e.printStackTrace();
                      }
                  }
              }
          }
      }
      ```
    
    - 例2：测试available方法初始化byte[]数组，读一次就搞定。
    
      ```java
      public class FileInputStreamTest02 {
          public static void main(String[] args) {
              FileInputStream fis = null;
              try {
                  fis = new FileInputStream("tempFile.txt");
      //            System.out.println("剩余未读取的字节数：" + fis.available());
      //            System.out.println("当前读到的1个字节的字符的ascii码：" + fis.read());
      //            System.out.println("剩余未读取的字节数：" + fis.available());
                  int len = fis.available();
                  byte[] bytes = new byte[len];
                  fis.read(bytes);
                  System.out.println(new String(bytes));
              } catch (FileNotFoundException e) {
                  e.printStackTrace();
              } catch (IOException e) {
                  e.printStackTrace();
              } finally{
                  if (fis != null) {
                      try {
                          fis.close();
                      } catch (IOException e) {
                          e.printStackTrace();
                      }
                  }
              }
          }
      }
      ```
    
    - 例3：在例2的基础上，测试skip方法跳过3个字节不读。
    
      ```java
      public class FileInputStreamTest02 {
          public static void main(String[] args) {
              FileInputStream fis = null;
              try {
                  fis = new FileInputStream("tempFile.txt");
      //            System.out.println("剩余未读取的字节数：" + fis.available());
      //            System.out.println("当前读到的1个字节的字符的ascii码：" + fis.read());
      //            System.out.println("剩余未读取的字节数：" + fis.available());
                  int len = fis.available();
                  byte[] bytes = new byte[len];
                  fis.skip(3);
                  fis.read(bytes);
                  System.out.println(new String(bytes));
              } catch (FileNotFoundException e) {
                  e.printStackTrace();
              } catch (IOException e) {
                  e.printStackTrace();
              } finally{
                  if (fis != null) {
                      try {
                          fis.close();
                      } catch (IOException e) {
                          e.printStackTrace();
                      }
                  }
              }
          }
      }
      
      ```

- java.io.FileOutputStream

  - 构造方法

    ```
    FileOutputStream(String name) ；
    执行write()方法时，将文件内容先清空后写入数据。
    
    FileOutputStream(String name, boolean append) ；
    执行write()方法时，apend为true时，在文件内容末尾追加写入数据。
    ```

  - 常用方法

    ```
    void write(byte[] b) ；
    将 b.length 个字节从指定 byte 数组写入此文件输出流中。 
    
    void write(byte[] b, int off, int len)
    从偏移量 off 开始的指定字节数组中将 len 字节写入此文件输出流。
    
    void close() ；
    关闭此文件输出流并释放与此流有关的所有系统资源。 
    ```

  - 固定写法

    ```java
    FileOutputStream fos = null;
    try{
        fos = new FileOutputStream(文件路径); //文件路径中的文件不存在时会自动创建
        
        fos.flush(); //写完后一定记得刷新
    }catch(){
    
    }finally{
        if(fos != null){
            fos.close();
        }
    
    }
    ```

    - 例1：拷贝文件（字节流可拷贝任何类型的文件）

      ```java
      FileInputStream fis = null;
      FileOutputStream fos = null;
      try {
          fis = new FileInputStream("E:\\CloudMusic\\广东雨神-广东爱情故事.wav");
          fos = new FileOutputStream("G:\\学习\\Java Project\\广东雨神-广东爱情故事.wav");
      
          // 最核心的：一边读，一边写
          byte[] bytes = new byte[1024 * 1024]; // 1MB（一次最多拷贝1MB。）
          int readCount = 0;
          while((readCount = fis.read(bytes)) != -1) {
              fos.write(bytes, 0, readCount);
          }
      
          // 刷新，输出流最后要刷新
          fos.flush();        
      } catch () {
                 
      } finally {
          // 分开try，不要一起try。
          // 一起try的时候，其中一个出现异常，可能会影响到另一个流的关闭。
          if (fos != null) {
                  fos.close();
          }
      
          if (fis != null) {
              fis.close();                
          }
      }
      ```

- java.io.FileReader

  - 构造方法

    ```
    FileReader(String fileName) 
    在给定从中读取数据的文件名的情况下创建一个新 FileReader。
    ```

  - 常用方法

    ```
    int read() ：从此输入流中读取一个数据字符。 
    int read(char[] c) ：从此输入流中将最多 c.length 个字符的数据读入一个 char 数组中。 
    ```

    - 例1：照葫芦画瓢，根据FileInputStream的写法实例，写FileReader的。

      ```java
      public class FileReaderTest01 {
          public static void main(String[] args) {
              FileReader fr = null;
              try {
                  fr = new FileReader("outFile.txt");
                  char[] chars = new char[4];
                  int readCount = 0;
                  while((readCount = fr.read(chars)) != -1){
                      System.out.print(new String(chars, 0, readCount));
                  }
      
              } catch (FileNotFoundException e) {
                  e.printStackTrace();
              } catch (IOException e) {
                  e.printStackTrace();
              } finally{
                  if (fr != null) {
                      try {
                          fr.close();
                      } catch (IOException e) {
                          e.printStackTrace();
                      }
                  }
              }
          }
      }
      
      ```

- java.io.FileWriter

  - 构造方法

    ```
    FileWriter(String fileName)
    文件不存在则创建，若文件存在则调用writer()时会先清空原有数据，再写入数据。 
    
    FileWriter(String fileName, boolean append)
    文件不存在则创建，若文件存在并且append为true时，会在文件末尾追加数据。
    ```

  - 常用方法

    ```
    void write(int c);
    将ascii码c所代表的的一个字符写入文件。
    
    void write(char[] cbuf);
    将字符数组cbuf中的所有字符写入文件。
    
    void write(String str);
    将字符串str写入文件。
    ```

    - 例1：照葫芦画瓢，根据FileOutputStream的写法实例，写FileWriter的。

      ```java
      public class FileWriterTest01 {
          public static void main(String[] args) {
              FileWriter fw = null;
              try {
                  fw = new FileWriter("outFile2.txt");
      
                  char[] chars = {'我','是','中','国','人'};
                  fw.write(chars);
                  fw.write(chars, 2, 3);
                  
                  String str = "我爱中国";
                  fw.write(str);
                  fw.write(str, 0, 2);
      
                  fw.flush();
              } catch (IOException e) {
                  e.printStackTrace();
              } finally{
                  if (fw != null) {
                      try {
                          fw.close();
                      } catch (IOException e) {
                          e.printStackTrace();
                      }
                  }
              }
      
          }
      }
      ```

    - 例2：拷贝文件（字符流只能拷贝文本文件）

      ```
      FileReader fr = null;
      FileWriter fw = null;
      try {
          fr = new FileReader("E:\\ThreeBody.txt");
          fw = new FileWriter("G:\\学习\\Java Project\\ThreeBoday.txt");
      
          char[] chars = new char[1024 * 512]; 
          // 在java中1个char类型字符占用两个字节，1024 * 512 * 2就占用1MB
      
          int num = 0;
          while((num = fr.read(chars)) != -1){
              fw.write(chars, 0, num);
          }
          fw.flush();
      } catch () {
      
      } finally{
          if(fr != null){
              fr.close();
          }
          
          if(){
              fw.close();
          }
          
      }
      ```

      

### 20.5.2 缓冲流专属

```
java.io.BufferedReader
java.io.BufferedWriter
java.io.BufferedInputStream
java.io.BufferedOutputStream
```

当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流。

外部负责包装的这个流，叫做：包装流，还有一个名字叫做：处理流。

- java.io.BufferedReader

  - 构造方法

    ```
    BufferedReader(Reader in) 
    创建一个使用默认大小输入缓冲区的缓冲字符输入流，参数为Reader的子类对象。
    ```

  - 常用方法

    ```
    String readLine() 
    读取一个文本行，当读到没有文本行时，返回null。
    ```

  - 例1：使用BufferedReader读取文本文件

    ```java
    public class BufferedReaderTest01 {
        public static void main(String[] args) {
            FileReader fr = null;
            BufferedReader br = null;
            try {
                fr = new FileReader("tempFile.txt");
                br = new BufferedReader(fr);
    
                String str = null;
                while((str = br.readLine()) != null){ //readLine()方法每次读取文本文件中的一行，读到文件尾部返回null
                    System.out.println(str);
                }
    
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally{
                if (br != null) {
                    try {
                        br.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ```

  - 例2：将一个字节流转换成字符流，使用BufferedReader读取文本文件

    ```java
    public class BufferedReaderTest02 {
        public static void main(String[] args) {
            // 字节流如何转换成字符流
            // InputStreamReader
            FileInputStream fis = null;
            InputStreamReader isr = null;
            BufferedReader br = null;
            try {
                fis = new FileInputStream("test02/src/com/lzk/io/test01/CopyTest01.java");
                isr = new InputStreamReader(fis);
                br = new BufferedReader(isr);
                String str = null;
                while((str = br.readLine()) != null){
                    System.out.println(str);
                }
    
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally{
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    ```

  - 例3：将例2中的三句new对象代码合成一句；

    ```java
    public class BufferedReaderTest03 {
        public static void main(String[] args) {
            BufferedReader br = null;
            try {
                br = new BufferedReader(new InputStreamReader(new FileInputStream("Test02/src/com/lzk/io/test01/CopyTest01.java")));
                String str = null;
                while((str = br.readLine()) != null){
                    System.out.println(str);
                }
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                if (br != null) {
                    try {
                        br.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ```

- java.io.BufferedWriter

  - 构造方法

    ```
    BufferedWriter(Writer out) 
    创建一个使用默认大小输出缓冲区的缓冲字符输出流，参数为Writer的子类对象。
    ```

  - 常用方法

    ```
    void write(String s) 
    写入一个字符串。 
    ```

  - 例1：使用BufferedWriter将若干字符串写入文本文件中.

    ```java
    public class BufferedWriterTest01 {
        public static void main(String[] args) {
            BufferedWriter bw = null;
            try {
                bw = new BufferedWriter(new FileWriter("xxx"));
                bw.write("hello world");
                bw.write("I will be back!");
                bw.flush();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                if (bw != null) {
                    try {
                        bw.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ```

  - 例2：使用OutputStreamWriter将字节流转换成字符流.

    ```java
    public class BufferedWriterTest02 {
        public static void main(String[] args) {
            BufferedWriter bw = null;
            try {
                bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("xxx", true)));
                bw.write("my name is Joker!");
                bw.flush();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally{
                if (bw != null) {
                    try {
                        bw.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ```

### 20.5.3 转换流（将字节流转换成为字符流）

```
java.io.InputStreamReader
java.io.OutputStreamWriter
```

### 20.5.4 数据流专属

```
java.io.DataInputStream
java.io.DataOutputStream

注意：
DataOutputStream可以将数据连同数据的类型一并写入文件。这个文件不是普通文本文档。（这个文件使用记事本打不开。）
DataOutputStream写的文件，只能使用DataInputStream去读。并且读的时候你需要提前知道写入的顺序。
读的顺序需要和写的顺序一致。才可以正常取出数据。
```

- java.io.DataOutputStream

  - 构造方法

    ```
    DataOutputStream(OutputStream out) 
    创建一个新的数据输出流，将数据写入指定基础输出流，参数为OutputStream的子类对象。
    ```

  - 例：利用DataOutputStream把八种数据类型的数据写入文本文件中

    ```java
    public class DataOutputStreamTest01 {
        public static void main(String[] args) {
            DataOutputStream dos = null;
            try {
                dos = new DataOutputStream(new FileOutputStream("yyy"));
                byte b = 1;
                short s = 2;
                int i = 3;
                long l = 4;
                float f = 3.14f;
                double d = 2.45;
                boolean bool = true;
                char c = 'a';
                dos.writeByte(b);
                dos.writeShort(s);
                dos.writeInt(i);
                dos.writeLong(l);
                dos.writeFloat(f);
                dos.writeDouble(d);
                dos.writeBoolean(bool);
                dos.writeChar(c);
                dos.flush();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                if (dos != null) {
                    try {
                        dos.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ```

- java.io.DataInputStream

  - 构造方法

    ```
    DataInputStream(InputStream in) 
    使用指定的底层 InputStream 创建一个 DataInputStream。
    ```

  - 例：利用DataInputStream把写入文本文件中的八种数据类型的数据读取出来

    ```java
    public class DateInputStreamTest01 {
        public static void main(String[] args) {
            DataInputStream dis = null;
            try {
                dis = new DataInputStream(new FileInputStream("YYY"));
                byte b = dis.readByte();
                short s = dis.readShort();
                int i = dis.readInt();
                long l = dis.readLong();
                float f = dis.readFloat();
                double d = dis.readDouble();
                boolean bool = dis.readBoolean();
                char c = dis.readChar();
                System.out.println(b);
                System.out.println(s);
                System.out.println(i);
                System.out.println(l);
                System.out.println(f);
                System.out.println(d);
                System.out.println(b);
                System.out.println(c);
    
    
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                if (dis != null) {
                    try {
                        dis.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ```

### 20.5.5 标准输出流

```
java.io.PrintWriter
java.io.PrintStream（掌握）
```

- java.io.PrintStream（掌握）

  - 标准的字节输出流，默认输出到控制台，可以改变输出方向（如输出到某个文件），不需要手动close()关闭。

  - 构造方法

    ```
    PrintStream(OutputStream out) 
    创建新的打印流，参数为OutputStream的子类对象。
    ```

  - 固定写法

    ```
    // 默认输出到控制台
    System.out.println("I will be back");
    System.out.println("I am T-800!");
    
    // 改变输出方向，将其输出到文件mm.txt
    System.setOut(new PrintStream(new FileOutputStream("mm.txt")));
    
    // 改变后就输出到文件mm.txt了
    System.out.println("I will be back!");
    System.out.println("I am T-800!");
    ```


### 20.5.6 对象专属流

```
java.io.ObjectInputStream（掌握）
java.io.ObjectOutputStream（掌握）
```

- 序列化和反序列化的理解![image-20240613085108635](assets/image-20240613085108635.png)

- 参与序列化的类型必须实现java.io.Serializable接口

  - 否则会报告异常信息：java.io.NotSerializableException，即Student对象不支持序列化！！！！

  - 注意：通过源代码发现，Serializable接口只是一个标志接口：

    ```java
    public interface Serializable {
    
    }
    ```

    - 这个接口当中什么代码都没有。但是它起到标识的作用，标志的作用，java虚拟机看到这个类实现了这个接口，可能会对这个类进行特殊待遇。
    - Serializable这个标志接口是给java虚拟机参考的，java虚拟机看到这个接口之后，会为该类自动生成一个序列化版本号。

  - 例1：序列化一个Java对象

    ```java
    public class SerializableTest01{
        public static void main(String[] args) {
            Student stu = new Student("joker", 18);
            ObjectOutputStream oos = null;
            try {
                oos = new ObjectOutputStream(new FileOutputStream("stu"));
    
                oos.writeObject(stu);
    
                oos.flush();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                if (oos != null) {
                    try {
                        oos.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    
    class Student  implements Serializable{
        private String name;
        private int age;
    
        public Student() {
        }
    
        public Student(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    
        @Override
        public String toString() {
            return "Student{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }
    }
    ```

  - 例2：把刚才序列化的对象反序列化输出。

    ```java
    public class SerializableTest02 {
        public static void main(String[] args) {
            ObjectInputStream ois = null;
            try {
                ois = new ObjectInputStream(new FileInputStream("stu"));
                Object o = ois.readObject();
                System.out.println(o);
            } catch (IOException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } finally {
                if (ois != null) {
                    try {
                        ois.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    
    ```

- 可以一次序列化多个对象吗？

  - 可以，可以将对象放到集合当中，序列化集合。

  - 提示：参与序列化的ArrayList集合以及集合中的元素User都需要实现 java.io.Serializable接口。

  - 例1：序列化多个对象，再反序列化输出。

    ```java
    public class SerializableTest03 {
        public static void main(String[] args) {
            List<User> list = new ArrayList<>();
            list.add(new User("joker", 18));
            list.add(new User("danny", 19));
            list.add(new User("tony", 11));
            list.add(new User("superman", 25));
            ObjectOutputStream oos = null;
            try {
                oos = new ObjectOutputStream(new FileOutputStream("users"));
                oos.writeObject(list);
    
                oos.flush();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                if (oos != null) {
                    try {
                        oos.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    class User implements Serializable {
        private String name;
        private int age;
    
        public User() {
        }
    
        public User(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            User user = (User) o;
            return age == user.age &&
                    Objects.equals(name, user.name);
        }
    
        @Override
        public int hashCode() {
            return Objects.hash(name, age);
        }
    
        @Override
        public String toString() {
            return "User{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }
    }
    ```

    ```java
    public class SerializableTest04 {
        public static void main(String[] args) {
            ObjectInputStream ois = null;
            try {
                ois = new ObjectInputStream(new FileInputStream("users"));
                Object o = ois.readObject();
                if(o instanceof List){
                    List<User> list = (List<User>)o;
                    for(User user : list){
                        System.out.println(user);
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } finally{
                if (ois != null) {
                    try {
                        ois.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
    
        }
    }
    ```

- 可以不让某个属性参与序列化吗？

  - 可以，如果不希望类中某个属性参与序列化，则在该属性前加关键字transient。

  - 例：让一个类的某个属性不参与序列化，对该类的对象进行序列化后反序列化输出。

    ```java
    public class SerializableTest03 {
        public static void main(String[] args) {
            List<User> list = new ArrayList<>();
            list.add(new User("joker", 18));
            list.add(new User("danny", 19));
            list.add(new User("tony", 11));
            list.add(new User("superman", 25));
            ObjectOutputStream oos = null;
            try {
                oos = new ObjectOutputStream(new FileOutputStream("users"));
                oos.writeObject(list);
    
                oos.flush();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                if (oos != null) {
                    try {
                        oos.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    class User implements Serializable {
        transient String name;
        private int age;
    
        public User() {
        }
    
        public User(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            User user = (User) o;
            return age == user.age &&
                    Objects.equals(name, user.name);
        }
    
        @Override
        public int hashCode() {
            return Objects.hash(name, age);
        }
    
        @Override
        public String toString() {
            return "User{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }
    }
    ```

    ```java
    public class SerializableTest04 {
        public static void main(String[] args) {
            ObjectInputStream ois = null;
            try {
                ois = new ObjectInputStream(new FileInputStream("users"));
                Object o = ois.readObject();
                if(o instanceof List){
                    List<User> list = (List<User>)o;
                    for(User user : list){
                        System.out.println(user);
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } finally{
                if (ois != null) {
                    try {
                        ois.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
    
        }
    }
    
    ```

- 序列化版本号有什么用呢？

  - 自动生成的序列化版本号

    - 十年前编写了一个学生类，编译后生成了字节码，运行时自动生成了一个序列化版本号，硬盘上的学生对象数据是对应该序列化版本号。十年后我们要重新修改这个学生类中的一些属性，编译后生成了新的字节码，运行时自动生成了一个新的序列化版本号，这时反序列化时候就会失败，因为新生成的序列化版本号与老的序列化版本号不对应，旧版本的序列化后的数据无法反序列化为新版本的对象，会报告以下错误：

      ```
      java.io.InvalidClassException:
              com.bjpowernode.java.bean.Student;
              local class incompatible:
                  stream classdesc serialVersionUID = -684255398724514298（十年后）,
                  local class serialVersionUID = -3463447116624555755（十年前）
      ```

  - java语言中是采用什么机制来区分类的？

    - 第一：首先通过类名进行比对，如果类名不一样，肯定不是同一个类。
    - 第二：如果类名一样，再怎么进行类的区别？靠序列化版本号进行区分。
      - A编写了一个类：com.bjpowernode.java.bean.Student implements Serializable
      - B编写了一个类：com.bjpowernode.java.bean.Student implements Serializable
      - 不同的人编写了同一个类，但“这两个类确实不是同一个类”。这个时候序列化版本就起上作用了。
      - 对于java虚拟机来说，java虚拟机是可以区分开这两个类的，因为这两个类都实现了Serializable接口，都有默认的序列化版本号，他们的序列化版本号不一样。所以区分开了。（这是自动生成序列化版本号的好处）

  - 自动生成序列化版本号有什么缺陷？
    - 一旦代码确定之后，不能进行后续的修改，因为只要修改，必然会重新编译，此时会生成全新的序列化版本号，这个时候java虚拟机会认为这是一个全新的类。（这样就不好了！）

  - 最终结论：

    - 凡是一个类实现了Serializable接口，建议给该类提供一个固定不变的序列化版本号。并且建议将序列化版本号手动的写出来：

      ```
      private static final long serialVersionUID = 1L;
      ```

      - 这样，以后这个类即使代码修改了，但是版本号不变，java虚拟机会认为是同一个类。

      ```java
      class User implements Serializable {
          private static final long serialVersionUID = 1L;
          private String name;
          private int age;
          private int heigh;
      //    private boolean gender;
          public User() {
          }
          public User(String name, int age) {
              this.name = name;
              this.age = age;
          }
          public String getName() {
              return name;
          }
          public void setName(String name) {
              this.name = name;
          }
          public int getAge() {
              return age;
          }
          public void setAge(int age) {
              this.age = age;
          }
          @Override
          public boolean equals(Object o) {
              if (this == o) return true;
              if (o == null || getClass() != o.getClass()) return false;
              User user = (User) o;
              return age == user.age &&
                      Objects.equals(name, user.name);
          }
      
          @Override
          public int hashCode() {
              return Objects.hash(name, age);
          }
      
          @Override
          public String toString() {
              return "User{" +
                      "name='" + name + '\'' +
                      ", age=" + age +
                      '}';
          }
      }
      ```

## 20.6 java.io.File类

- File类的理解

  - File类和四大家族没有关系，所以File类不能完成文件的读和写。

  - File对象代表什么？

    - 文件和目录路径名的抽象表示形式。

      ```
      E:\FileTest  这是一个File对象
      E:\FileTest\file1.txt   也是一个File对象。
      ```

    - 一个File对象有可能对应的是目录，也可能是文件。

- 构造方法

  ```
  File(String pathname)
  通过将给定的路径名字符串转换为抽象路径名来创建一个新的 File 实例。
  ```

- 常用方法

  ```
  boolean exists()
  测试此抽象路径名表示的文件或目录是否存在。
  
  boolean createNewFile()
  当且仅当具有此名称的文件尚不存在时，以原子方式创建一个以此抽象路径名命名的新空文件。
  
  boolean mkdir() 
  创建以此抽象路径名命名的目录。
  
  boolean mkdirs()
  创建以此抽象路径名命名的目录，包括任何必需但不存在的父目录。
  
  String getParent()
  返回此抽象路径名的父目录的路径名字符串，如果此路径名未指定父目录，则返回 null。
  
  File getParentFile()
  返回此抽象路径名的父目录的路径File，如果此路径名未指定父目录，则返回 null。
  
  File getAbsoluteFile()
  返回此抽象路径名的绝对形式。
  
  
  String getName()
  返回此抽象路径名表示的文件或目录的名称。
  
  boolean isDirectory()
  测试此抽象路径名表示的文件是否为目录。
  
  boolean isFile()
  测试此抽象路径名表示的文件是否为普通文件。
  
  long lastModified()
  返回上次修改此抽象路径名表示的文件的时间。
  
  File[] listFiles() 
  返回一个抽象路径名数组，表示此抽象路径名表示的目录中的文件。
  ```

## 20.7 IO+Properties的联合应用

- 非常好的一个设计理念：以后经常改变的数据，可以单独写到一个文件中，使用程序动态读取。将来只需要修改这个文件的内容，java代码不需要改动，不需要重新编译，服务器也不需要重启。就可以拿到动态的信息。

- 类似于以上机制的这种文件被称为配置文件。并且当配置文件中的内容格式是：

  ```
  key1=value
  key2=value
  ```

  - 我们把这种配置文件叫做属性配置文件。

- java规范中有要求：属性配置文件建议以.properties结尾，但这不是必须的。这种以.properties结尾的文件在java中被称为：属性配置文件。其中Properties是专门存放属性配置文件内容的一个类。

  ```java
  FileInputStream fis = null;
  try {
      fis = new FileInputStream("userInfo.properties");
      Properties p = new Properties();
      p.load(fis); // load()中的参数除了InputStream的子类对象还可以是Reader的子类对象
      System.out.println(p.getProperty("username"));
      System.out.println(p.getProperty("no"));
      System.out.println(p.getProperty("age"));
  } catch (FileNotFoundException e) {
  	e.printStackTrace();	
  } catch (IOException e) {
  	e.printStackTrace();
  } finally{
  	if(fis != null){
          try {
              fis.close();
          } catch (IOException e) {
              e.printStackTrace();
          }
  	}
  }
  ```

  <img src="assets/image-20240613112024763.png" alt="image-20240613112024763" style="zoom: 50%;" />

# 21.多线程

## 21.1 线程概述

- 什么是进程？什么是线程？它们的区别？
  - 进程是指操作系统中的一段程序，它是一个正在执行中的程序实例，具有独立的内存空间和系统资源，如文件、网络端口等。在计算机程序执行时，先创建进程，再在进程中进行程序的执行。一般来说，一个进程可以包含多个线程。
  - 线程是指进程中的一个执行单元，是进程的一部分，它负责在进程中执行程序代码。每个线程都有自己的栈和程序计数器，并且可以共享进程的资源。多个线程可以在同一时刻执行不同的操作，从而提高了程序的执行效率。
  - 现代的操作系统是支持多进程的，也就是可以启动多个软件，一个软件就是一个进程。称为：多进程并发。
  - 通常一个进程都是可以启动多个线程的。称为：多线程并发。
- 多线程的作用？
  - 提高处理效率。（多线程的优点之一是能够使 CPU 在处理一个任务时同时处理多个线程，这样可以充分利用 CPU 的资源，提高 CPU 的利用效率。）
- JVM规范中规定：
  - 堆内存、方法区 是线程共享的。
  - 虚拟机栈、本地方法栈、程序计数器 是每个线程私有的。
- 关于Java程序的运行原理
  - “java HelloWorld”执行后，会启动JVM，JVM的启动表示一个进程启动了。
  - JVM进程会首先启动一个主线程（main-thread），主线程负责调用main方法。因此main方法是在主线程中运行的。
  - 除了主线程之外，还启动了一个垃圾回收线程。因此启动JVM，至少启动了两个线程。
  - 在main方法的执行过程中，程序员可以手动创建其他线程对象并启动。

## 21.2 并发与并行

- 并发

  - 使用单核CPU的时候，同一时刻只能有一条指令执行，但多个指令被快速的轮换执行，使得在宏观上具有多个指令同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干端，使多个指令快速交替的执行。

    ![image-20240626112918783](assets/image-20240626112918783.png)

  - 如上图所示，假设只有一个CPU资源，线程之间要竞争得到执行机会。图中的第一个阶段，在A执行的过程中，B、C不会执行，因为这段时间内这个CPU资源被A竞争到了，同理，第二阶段只有B在执行，第三阶段只有C在执行。其实，并发过程中，A、B、C并不是同时进行的（微观角度），但又是同时进行的（宏观角度）。

  - 在同一个时间点上，一个CPU只能支持一个线程在执行。因为CPU运行的速度很快，CPU使用抢占式调度模式在多个线程间进行着高速的切换，因此我们看起来的感觉就像是多线程一样，也就是看上去就是在同一时刻运行。

- 并行

  - 使用多核CPU的时候，同一时刻，有多条指令在多个CPU上同时执行。

    ![image-20240626113041604](assets/image-20240626113041604.png)

  - 如图所示，在同一时刻，ABC都是同时执行（微观、宏观）。

- 并发编程与并行编程

  - 在CPU比较繁忙（假设为单核CPU），如果开启了很多个线程，则只能为一个线程分配仅有的CPU资源，这些线程就会为自己尽量多抢时间片，这就是通过多线程实现并发，线程之间会竞争CPU资源争取执行机会。
  - 在CPU资源比较充足的时候（假设为多核CPU），一个进程内的多个线程，可以被分配到不同的CPU资源，这就是通过多线程实现并行。 
  - 至于多线程实现的是并发还是并行？上面所说，所写多线程可能被分配到一个CPU内核中执行，也可能被分配到不同CPU执行，分配过程是操作系统所为，不可人为控制。所以，如果有人问我我所写的多线程是并发还是并行的？我会说，都有可能。 
  - 总结：单核CPU上的多线程，只是由操作系统来完成多任务间对CPU的运行切换，并非真正意义上的并行。随着多核CPU的出现，也就意味着不同的线程能被不同的CPU核得到真正意义的并行执行，故而多线程技术得到广泛应用。
  - 不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源，而我们使用多线程的目的就是为了提高CPU资源的利用率。

## 21.3 线程的调度策略

- 如果多个线程被分配到一个CPU内核中执行，则同一时刻只能允许有一个线程能获得CPU的执行权，那么进程中的多个线程就会抢夺CPU的执行权，这就是涉及到线程调度策略。
- 线程调度策略
  - 分时调度策略
    - 所有线程轮流使用CPU的执行权，并且平均的分配每个线程占用的CPU的时间。
  - 抢占式调度策略
    - 让优先级高的线程以较大的概率优先获得CPU的执行权，如果线程的优先级相同，那么就会随机选择一个线程获得CPU的执行权，而Java采用的就是抢占式调用。

## 21.4 实现线程

### 21.4.1 实现方式1：继承Thread类

- 步骤

  - 编写一个类继承Thread，重写run方法。

  - 创建线程对象：Thread t = new MyThread();

  - 启动线程：t.start();

- 例1：继承Thread类，实现一个线程

  ```java
  // 调用start()后就会启动一个新线程
  // Java中有一个语法规则，对于方法体中的代码必须遵循自上而下的顺序依次逐行执行
  // start()不结束，main()是无法继续往下执行的
  // start()的特点是会瞬间结束，因为start()作用就是启动一个新的线程，只要新线程启动成功了，start()就结束了
  public class MyThreadTest01  {
      public static void main(String[] args) {
          Thread t = new MyThread();
          t.start();
          for(int i = 0; i < 100; i++){
              System.out.println("主线程--->" + i);
          }
      }
  }
  class MyThread extends Thread{
      @Override
      public void run() {
          for(int i = 0; i < 100; i++){
              System.out.println("分支线程--->" + i);
          }
      }
  }
  
  ```

  - 以上程序的内存图如下：

    <img src="assets/image-20240627093749902.png" alt="image-20240627093749902" style="zoom: 50%;" />

- 例2：继承Thread类，实现一个线程，不调用线程的start(), 而直接调用线程的run()会发生什么。

  ```java
  // 直接调用run()，不会启动新的线程
  // Java中有一个语法规则，对于方法体中的代码，必须遵循自上而下的顺序依次执行。
  // run()不结束，main()是无法继续往下执行的
  
  public class MyThreadTest01  {
      public static void main(String[] args) {
          Thread t = new MyThread();
          t.run();
          for(int i = 0; i < 100; i++){
              System.out.println("主线程--->" + i);
          }
      }
  }
  class MyThread extends Thread{
      @Override
      public void run() {
          for(int i = 0; i < 100; i++){
              System.out.println("分支线程--->" + i);
          }
      }
  }
  // 会输出完"分支线程--->0"~"分支线程--->99"
  // 再输出"主线程--->0" ~ "主线程--->99"
  ```

  - 以上程序的内存图如下：

    <img src="assets/image-20240627093829873.png" alt="image-20240627093829873" style="zoom: 50%;" />

### 21.4.2 实现方式2：实现Runnable接口

- 步骤

  - 编写一个类实现Runnable接口，实现run方法。
  - 创建线程对象：Thread t = new Thread(new MyRunnable());
  - 启动线程：t.start();

- 例：实现Runnable接口，实现一个线程

  ```java
  public class MyThreadTest02 {
      public static void main(String[] args) {
          Thread t = new Thread(new MyRunnable());
          t.start();
          for(int i = 0; i < 100; i++){
              System.out.println("主线程--->" + i);
          }
      }
  }
  
  class MyRunnable implements Runnable{
  
      @Override
      public void run() {
          for(int i = 0; i < 100; i++){
              System.out.println("分支线程--->" + i);
          }
      }
  }
  ```

- 注：优先选择第二种方式：因为实现接口的同时，保留了类的继承。

- 第二种方式也可以使用匿名内部类。

  ```java
  public class MyThreadTest03 {
      public static void main(String[] args) {
          Thread t = new Thread(new Runnable() {
              @Override
              public void run() {
                  for(int i = 0; i < 100; i++){
                      System.out.println("分支线程--->" + i);
                  }
              }
          });
          t.start();
          for(int i = 0; i < 100; i++){
              System.out.println("主线程--->" + i);
          }
      }
  }
  ```

### 21.4.3 线程常用的三个方法

- 实例方法

  ```
  String getName(); 
  void setName(String name);
  ```

- 静态方法

  ```
  static Thread currentThread();
  ```

- 例1：获取主线程和分支线程的默认名称

  ```java
  public class MyThreadTest04 {
      public static void main(String[] args) {
          System.out.println(Thread.currentThread().getName());
          Thread t1 = new MyThread02();
          Thread t2 = new MyThread02();
          t1.start();
          t2.start();
      }
  }
  class MyThread02 extends Thread{
      @Override
      public void run() {
          System.out.println("分支线程--->" + Thread.currentThread().getName());
      }
  }
  ```

- 例2：修改主线程的名称

  ```java
  public class MyThreadTest05 {
      public static void main(String[] args) {
          Thread.currentThread().setName("newMain");
          System.out.println(Thread.currentThread().getName());
      }
  }
  ```

- 例3：用实例方法修改分支线程的名称

  ```java
  public class MyThreadTest05 {
      public static void main(String[] args) {
          Thread t1 = new MyThread03();
          Thread t2 = new MyThread03();
          t1.setName("joker");
          t2.setName("batman");
          t1.start();
          t2.start();
      }
  }
  
  class MyThread03 extends Thread{
      @Override
      public void run() {
          System.out.println("分支线程--->" + Thread.currentThread().getName());
      }
  }
  ```

- 例4：用构造方法修改分支线程的名称

  ```java
  public class MyThreadTest06 {
      public static void main(String[] args) {
          Thread t1 = new MyThread04("joker");
          Thread t2 = new MyThread04("batman");
          t1.start();
          t2.start();
      }
  }
  
  class MyThread04 extends Thread{
      public MyThread04(String name) {
          super(name);
      }
  
      @Override
      public void run() {
          System.out.println("分支线程--->" + Thread.currentThread().getName());
      }
  }
  ```

  

## 21.5 线程的生命周期

- 线程生命周期指的是：从线程对象新建，到最终线程死亡的整个过程。

- 线程生命周期包括七个重要阶段：

  ```
  新建状态（NEW）
  就绪状态（RUNNABLE）
  运行状态（RUNNABLE）
  超时等待状态（TIMED_WAITING）
  等待状态（WAITING）
  阻塞状态（BLOCKED）
  死亡状态（TERMINATED）
  ```

21.6 线程的休眠与终止

21.7 守护线程

21.8 定时任务

21.9 线程的调度

21.10 线程安全问题

21.11 线程间的通信

21.12 单例模式的线程安全问题

21.13 可重入锁

21.14 Callable实现线程

21.15 线程池实现线程



















































## 21.1 线程简介

### 21.1.1 进程和线程

- 说起进程，就不得不说一下程序。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。
- 而进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位。
  - 进程就像是一个独立的厨房，每个厨房有自己的一套设备、食材和厨师。每个进程在计算机中是一个独立运行的程序，拥有自己的内存空间和系统资源。进程之间是彼此独立的，就像不同的厨房，互相之间不会直接干扰。
- 通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位。
  - 线程可以看作是一个厨房里的不同厨师。虽然他们在同一个厨房里工作，但每个厨师（线程）可以独立处理不同的任务。例如，一个厨师在切菜，另一个在炒菜，还有一个在煮汤。线程共享同一个厨房的资源，比如锅碗瓢盆（内存、文件等）。
- 注意：很多“多线程”是模拟出来的，真正的多线程是指有多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以有同时执行的错觉。
  - 多线程是指在同一个进程（厨房）中有多个线程（厨师）同时工作。这样可以更快地完成任务，因为多个线程可以并行处理不同的任务。
  - 例如：
    - 在一个文本编辑器中，一个线程负责响应用户输入，另一个线程负责自动保存文件，还有一个线程负责拼写检查。
    - 在一个网页浏览器中，一个线程负责加载网页，另一个线程负责渲染图像，还有一个线程负责处理用户的点击操作。

- 普通方法调用和多线程

  <img src="assets/image-20240614101105451.png" alt="image-20240614101105451" style="zoom:50%;" />

- 本章核心概念

  - 线程就是独立的执行路径；
  - 在程序运行时，积食没有自己创建线程，后台也会有多个线程，如主线程main和gc线程。
  - main()称之为主线程，为系统的入口，用于执行整个程序。
  - 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的。
  - 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制。
  - 线程为带来额外的开销，如CPU调度时间，并发控制开销。
  - 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。



## 21.2 线程实现（重点）

### 21.2.1 三种创建方式

- 继承Thread类（重点）

  - 自定义线程类继承Thread类

  - 重写run()方法，编写线程执行体

  - 创建线程对象，调用stat()方法启动线程

  - 注意：线程开启不一定立即执行，由CPU调度执行

    ```java
    public class MyThread01 extends Thread{
        @Override
        public void run() {
            for(int i = 0; i < 100; i++){
                System.out.println("分支线程--->" + i);
            }
        }
        public static void main(String[] args) {
            MyThread01 t = new MyThread01();
            t.start();
            for(int i = 0; i < 100; i++){
                System.out.println("主线程--->" + i);
            }
        }
    }
    ```

    

- 实现Runnable接口（重点）

  - 定义MyRunnable类实现Runnable接口

  - 实现run()方法，编写线程执行体

  - 创建线程对象，调用start()方法启动线程

  - 注意：推荐使用Runnable对象，因为Java单继承的局限性

    ```java
    public class MyThread02 implements Runnable{
        @Override
        public void run() {
            for(int i = 0; i < 100; i++){
                System.out.println("分支线程--->" + i);
            }
        }
    
        public static void main(String[] args) {
    
            MyThread02 t = new MyThread02();
            new Thread(t).start();
    
            for(int i = 0; i < 100; i++){
                System.out.println("主线程-->" + i);
            }
        }
    }
    ```

  - 例：发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱

    ```java
    // 多个线程同时操作同一个对象
    // 买火车票的例子
    public class MyThread03 implements Runnable{
        private int ticketNumber = 10;
        @Override
        public void run() {
            while(true){
                if(ticketNumber <= 0){
                    break;
                }
                System.out.println(Thread.currentThread().getName() + "抢到了第" + this.ticketNumber-- + "票");
            }
        }
        public static void main(String[] args) {
            MyThread03 ticket = new MyThread03(); // 几个线程共享的东西
            new Thread(ticket, "joker").start();
            new Thread(ticket, "batman").start();
            new Thread(ticket, "superman").start();
            new Thread(ticket, "ironman").start();
    
        }
    }
    /*
    ironman抢到了第10票
    ironman抢到了第9票
    ironman抢到了第8票
    ironman抢到了第7票
    batman抢到了第10票
    superman抢到了第10票
    joker抢到了第10票
    joker抢到了第9票
    joker抢到了第8票
    superman抢到了第9票
    superman抢到了第8票
    superman抢到了第7票
    superman抢到了第6票
    superman抢到了第5票
    batman抢到了第9票
    ironman抢到了第6票
    ironman抢到了第5票
    ironman抢到了第4票
    ironman抢到了第3票
    batman抢到了第8票
    batman抢到了第7票
    batman抢到了第6票
    batman抢到了第5票
    superman抢到了第4票
    joker抢到了第7票
    superman抢到了第3票
    batman抢到了第4票
    ironman抢到了第2票
    batman抢到了第3票
    superman抢到了第2票
    joker抢到了第6票
    superman抢到了第1票
    batman抢到了第2票
    ironman抢到了第1票
    batman抢到了第1票
    joker抢到了第5票
    joker抢到了第4票
    joker抢到了第3票
    joker抢到了第2票
    joker抢到了第1票
    
    */
    ```

  - 例2：龟兔赛跑

    - 首先来个赛道距离，然后要离终点越来越近
    - 判断比赛是否结束
    - 打印出胜利者
    - 龟兔赛跑开始
    - 故事中乌龟是赢的，兔子需要睡觉，所以我们来模拟兔子睡觉
    - 终于，乌龟赢得比赛。

    ```
    package com.lzk.test18;
    
    public class MyThread04 implements Runnable{
    
        private String winner = null;
    
        @Override
        public void run() {
             boolean flag = false;
            for(int i = 0; i <= 100; i++){
                System.out.println(Thread.currentThread().getName() + "跑了" + i + "步！");
                if(Thread.currentThread().getName().equals("兔子") && i % 30 == 0){
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                flag = gameOver(i);
                if(flag){
                    break;
                }
            }
        }
    
        private boolean gameOver(int step){
            if(winner != null){
                return true;
            }else{
                if(step >= 100){
                    winner = Thread.currentThread().getName();
                    System.out.println("winner is " + winner);
                    return true;
                }
            }
            return false;
        }
    
        public static void main(String[] args) {
            MyThread04 runway = new MyThread04();
            new Thread(runway, "兔子").start();
            new Thread(runway, "乌龟").start();
        }
    }
    
    ```

    

- 实现Callable接口（了解）


### 21.2.2 Lamda表达式

- 为什么要使用Lamda表达式？

  - 避免匿名内部类定义过多；
  - 可以让你的代码看起来更简洁；
  - 去掉了一堆没有意义的代码，只留下核心的逻辑。

- 理解Functional Interface（函数式接口）是学习Java8 Lambda表达式的关键所在。

  - 函数式接口的定义：

    - 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。

      ```java
      public Interface Runnable{
      	public abstract void run();
      }
      ```

    - 对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。

  - 注意：

    - lambda表达式只能有一行代码的情况下才能简化成为一行，如果有多行，那么就用代码块包裹；
    - 前提是接口为函数式接口
    - 多个参数也可以去掉参数类型，要去掉就都去掉，但必须加上括号。

### 21.2.3 静态代理模式

- 真实对象和代理对象都要实现同一个接口；
- 代理对象要代理真实角色；
- 好处
  - 代理对象可以做很多真是对象做不了的事情
  - 真实对象专注做自己的事情；

## 21.3 线程状态

### 21.3.1 线程的五种状态

![image-20240619112543462](assets/image-20240619112543462.png)

### 21.3.2 线程方法

```
更改线程的优先级
setPriority(int newPriority)

在指定的毫秒数内让当前正在执行的线程休眠
static void sleep(long millis)

等待线程终止
void join()

暂停当前正在执行的线程对象，并执行其他线程
static void yield()

中断线程(不建议使用这种方式)
void interrupt()

测试线程是否处于活动状态
boolean isAlive()
```

- 停止线程

  - 不推荐使用JDK提供的stop()、destroy()方法，已废弃。
  
  
    - 推荐线程自己停下来。
  
  
    - 建议使用一个标志位进行终止变量，当flag=false，则终止线程运行。
  
      ```java
      public class TestStop implements Runnable{
      	//1.线程中定义线程体使用的标识
      	private boolean flag = true;
      	public void run(){
      		//2.线程体使用该标识
      		while(flag){
      			System.out.println("run.. Thread");
      		}
      	}
      	//3.对外提供方法改变标识
      	public void stop(){
      		this.flag = false;
      	}
      }
      ```
  


- 线程休眠

  - 线程休眠

    - sleep(时间)指定当前线程阻塞的毫秒数；

    - sleep存在异常InterruptedException；

    - sleep时间到达后线程进入就绪状态；

    - sleep可以模拟网络延时，倒计时等。

    - 每一个对象都有一个锁，sleep不会释放锁。

  - 例1：模拟倒计时

    ```
    public class ThreadStopTest02 implements Runnable{
        @Override
        public void run() {
            int num = 10;
            while(true){
                System.out.println(num--);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if(num <= 0){
                    break;
                }
            }
        }
        public static void main(String[] args) {
            ThreadStopTest02 t = new ThreadStopTest02();
            new Thread(t).start();
        }
    }
    ```

  - 例2：模拟时间走

    ```
    public class ThreadSleepTest01 implements Runnable{
        @Override
        public void run() {
            Date d = new Date();
            while(true){
    
                System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(d));
                d = new Date(); //更新当前时间
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    
        public static void main(String[] args) {
            ThreadSleepTest01 t = new ThreadSleepTest01();
            new Thread(t).start();
        }
    }
    ```

- 线程礼让

  - 让当前正在执行的线程从运行状态转为就绪状态

  - 让CPU重新调度，礼让不一定成功！看CPU心情。

    ```java
    public class ThreadYieldTest01 implements Runnable {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + "开始执行！");
            Thread.yield();
            System.out.println(Thread.currentThread().getName() + "结束执行！");
        }
    
        public static void main(String[] args) {
            ThreadYieldTest01 t = new ThreadYieldTest01();
            new Thread(t, "joker").start();
            new Thread(t, "batman").start();
        }
    }
    
    ```

- 线程强制执行

  - join合并线程，其他线程处于阻塞状态，待此线程执行完成后，再执行其他线程。

  - 可以想象成插队。

    ```
    public class ThreadJoinTest01 implements Runnable{
    
        @Override
        public void run() {
            for(int i = 0; i < 1000; i++){
                System.out.println("分支线程--->" + i);
            }
        }
    
        public static void main(String[] args) {
            ThreadJoinTest01 t = new ThreadJoinTest01();
            Thread thread = new Thread(t);
            thread.start();
            for(int i = 0; i < 500; i++){
                System.out.println("主线程--->" + i);
                if(i == 450){
                    try {
                        thread.join();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ```

- 线程状态观测

  - Thread.State查看线程状态，线程可以处于以下状态之一：
    - NEW：尚未启动的线程处于此状态。

    - RUNNABLE：再Java虚拟机中执行的线程处于此状态。

    - BLOCKED：被阻塞等待监视器锁定的线程处于此状态。

    - WAITING：正在等待另一个线程执行特定动作的线程处于此状态。

    - TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。

    - TERMINATED：已退出的线程处于此状态。

    - 一个线程可以再给定时间点处于一个状态，这些状态是不反应任何操作系统线程状态的虚拟机状态。

      ```java
      public class StateTest01 implements Runnable{
      
      
          @Override
          public void run() {
              for (int i = 0; i < 5; i++) {
                  try {
                      Thread.sleep(1000);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
          }
      
          public static void main(String[] args) {
              // 新生状态
              StateTest01 t = new StateTest01();
              Thread thread =  new Thread(t);
              Thread.State state = thread.getState();
              System.out.println(state);
      
              // 运行状态
              thread.start();
              state = thread.getState();
              System.out.println(state);
      
              // 等待或终止状态
              while(state != Thread.State.TERMINATED){
                  try {
                      Thread.sleep(100);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  state = thread.getState();
                  System.out.println(state);
              }
          }
      }
      
      ```

- 线程优先级


    - Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。



    - 线程的优先级用数字表示，范围从1~10.
    
      ```
      Thread.MIN_PRIORITY = 1;
      Thread.MAX_PRIORITY = 10;
      Thread.NORM_PRIORITY = 5;
      ```
    
      - 注：优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看CPU的调度。
      - 注：优先级高只是意味着获得调度的概率高，但是这并不能保证高优先级的线程会在低优先级的线程前执行。
      - 注：优先级的设定建议在start()调度前。



  - 使用以下方式获取优先级或改变优先级

      ```
      .getPriority()
      .setPriority(int xxx)
      ```

      ```
      public class PriorityTest01 {
          public static void main(String[] args) {
              MyThread t = new MyThread();
              Thread thread1 = new Thread(t, "T-A");
              Thread thread2 = new Thread(t, "T-B");
              Thread thread3 = new Thread(t, "T-C");
              Thread thread4 = new Thread(t, "T-D");
              Thread thread5 = new Thread(t, "T-E");
      
              thread1.setPriority(1);
              thread2.setPriority(3);
              thread3.setPriority(5);
              thread4.setPriority(7);
              thread5.setPriority(Thread.MAX_PRIORITY);
              thread1.start();
              thread2.start();
              thread3.start();
              thread4.start();
              thread5.start();
      
          }
      }
      
      class MyThread implements Runnable{
      
          @Override
          public void run() {
              System.out.println(Thread.currentThread().getName() + "--->" + Thread.currentThread().getPriority());
          }
      }
      ```

- 守护线程


  - java语言中线程分为两大类：用户线程和守护线程（后台线程），其中具有代表性的就是 垃圾回收线程（守护线程）。

  - 守护线程的特点：一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束。


    - 注意：主线程main方法是一个用户线程。

  - 守护线程用在什么地方呢？


    - 每天00:00的时候系统数据自动备份。这个需要使用到定时器，并且我们可以将定时器设置为守护线程。让它一直在那里看着，每到00:00的时候就备份一次。所有的用户线程如果结束了，守护线程自动退出，没有必要进行数据备份了。

  - 将一个线程设置为守护线程：

    ```
    void setDaemon(boolean on)：实例方法，将一个用户线程设置为守护线程；
    ```

    ```
    public class DaemonTest01 {
        public static void main(String[] args) {
            God god = new God();
            You you = new You();
            Thread tGod = new Thread(god);
            Thread tYou = new Thread(you);
            tGod.setDaemon(true);
            tGod.start();
            tYou.start();
        }
    
    }
    class You implements Runnable{
    
        @Override
        public void run() {
            for(int i = 0; i < 365000; i++){
                System.out.println("你活着！");
            }
            System.out.println("=====你走了！=========");
        }
    }
    
    class God implements Runnable{
    
        @Override
        public void run() {
            while(true){
                System.out.println("上帝保护！");
            }
    
        }
    }
    ```

    


## 21.4 线程同步（重点）

### 21.4.1 线程同步基本概念

- 并发：同一个对象被多个线程同时操作。
  - 例如：上万人同时抢100张票，两个银行同时对一个账户取钱。
- 处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池 形成队列，等待前面的线程使用完毕，下一个线程再使用。
- 由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制（synchronized），当一个线程同时获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，但存在以下问题。
  - 一个线程持有锁会导致其他所有需要此锁的线程挂起；
  - 在多线程竞争下，加锁或释放锁会导致比较多的上下文切换 和 调度延时，引起性能问题。
  - 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。

### 21.4.2 三大线程不安全案例

- 案例1：多个线程在同一车站买票

  - 问题：多个线程可能会同时读取到相同的ticketNum值，从而导致多个线程“拿到”同一张票。

  ```java
  public class ThreadUnsafeTest01 {
      public static void main(String[] args) {
          Station station = new Station();
          new Thread(station, "A").start();
          new Thread(station, "B").start();
          new Thread(station, "C").start();
          new Thread(station, "D").start();
  
      }
  }
  class Station implements Runnable{
      private int ticketNum = 10;
      private boolean flag = true;
      @Override
      public void run() {
          while(flag){
              try {
                  buyTicket();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
      private void buyTicket() throws InterruptedException {
          if(ticketNum <= 0){
              flag = false;
              return;
          }
          Thread.sleep(100);
          System.out.println(Thread.currentThread().getName() + "拿到了第" + ticketNum + "票！");
          ticketNum = ticketNum - 1;
      }
  }
  ```

- 案例2：两个线程对同一账户取款

  ```java
  public class ThreadUnsafeTest02 {
      public static void main(String[] args) {
          Account act = new Account("12232077", 10000);
          new Thread(act, "joker").start();
          new Thread(act, "batman").start();
      }
  
  }
  class Account implements Runnable{
      public String actNo;   // 账号
      public int balance;    // 余额
  
      public Account() {
      }
  
      public Account(String actNo, int balance) {
          this.actNo = actNo;
          this.balance = balance;
      }
  
      @Override
      public void run() {
          int money = 5000;
          withDraw(money);
          System.out.println(Thread.currentThread().getName() + "在" + actNo + "账户中取款" + money + "，还剩" + balance + "元");
  
      }
      public void withDraw(int money){
          int before = balance;
          int after = before - money;
  
          balance = after;
      }
  }
  ```

- 案例3：ArrayList添加元素，最后元素数量不一定达到预期

  ```java
  public class ThreadUnsafeTest03 {
      public static void main(String[] args) {
          MyThread t = new MyThread();
          for(int i = 0; i < 1000; i++){
              new Thread(t).start();
          }
          System.out.println(t.list.size());
      }
  
  }
  
  class MyThread implements Runnable{
      ArrayList<String> list = new ArrayList<>();
      @Override
      public void run() {
          list.add(Thread.currentThread().getName());
      }
  }
  
  ```

  

## 21.5 线程通信问题



## 21.6 高级主题
